<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>firefly instrument &#8212; pySU, python Skies and Universes 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pySU, python Skies and Universes 1.0 documentation" href="index.html" />
    <link rel="next" title="firefly library" href="firefly_library.html" />
    <link rel="prev" title="firefly fitter" href="firefly_fitter.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>pySU, python Skies and Universes 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>firefly instrument</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="firefly_fitter.html">firefly fitter</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="firefly_library.html">firefly library</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="firefly-instrument">
<h1>firefly instrument<a class="headerlink" href="#firefly-instrument" title="Permalink to this headline">¶</a></h1>
<p>This class handles instrumental properties that influence the FIREFLY fitting process.</p>
<span class="target" id="module-firefly_instrument"></span><p>Provides a set of functions to handle instrumental effects.</p>
<p><a class="reference internal" href="#firefly_instrument.log_rebin" title="firefly_instrument.log_rebin"><code class="xref py py-func docutils literal"><span class="pre">log_rebin()</span></code></a> has been pulled from
<code class="xref py py-mod docutils literal"><span class="pre">mangadap.contrib.ppxf_util.py</span></code> and modified.</p>
<dl class="docutils">
<dt><em>Source location</em>:</dt>
<dd>$MANGADAP_DIR/python/mangadap/util/instrument.py</dd>
</dl>
<p><em>Python2/3 compliance</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>
</pre></div>
</div>
<p><em>Imports</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">InterpolatedUnivariateSpline</span>
<span class="kn">import</span> <span class="nn">astropy.constants</span>
</pre></div>
</div>
<dl class="docutils">
<dt><em>Revision history</em>:</dt>
<dd><div class="first last line-block">
<div class="line"><strong>27 May 2015</strong>: Original implementation by K. Westfall (KBW)
based on downgrader_MANGA.f provided by D. Thomas, O. Steele, D.
Wilkinson, D. Goddard.
13 June 2015: D.Wilkinson edit to not calculate unimportant
                convolution terms -&gt; runs 5x faster.</div>
</div>
</dd>
</dl>
<dl class="class">
<dt id="firefly_instrument.convolution_integral_element">
<em class="property">class </em><code class="descclassname">firefly_instrument.</code><code class="descname">convolution_integral_element</code><span class="sig-paren">(</span><em>y</em>, <em>sigma</em>, <em>ye=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#convolution_integral_element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.convolution_integral_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Support class for variable sigma convolution.  See
<a class="reference internal" href="#firefly_instrument.convolution_variable_sigma" title="firefly_instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a>.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">y (np.ndarray): Vector to convolve
sigma (np.ndarray): Coordinate-dependent standard deviation of the</p>
<blockquote>
<div>Gaussian kernel</div></blockquote>
<p class="last">ye (np.ndarray): (Optional) Error in the vector to convolve</p>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>Exception: Raised if <em>y</em> is not a 1D vector, or if the shape of</dt>
<dd><em>y</em> and <em>sigma</em> (and <em>ye</em> if provided) are different.</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><p class="first">x (np.ndarray): Pixel coordinate vector
y (np.ndarray): Vector to convolve
ye (np.ndarray): Error in the vector to convolve
sigma (np.ndarray): Coordinate-dependent standard deviation of the</p>
<blockquote>
<div>Gaussian kernel</div></blockquote>
<dl class="last docutils">
<dt>norm (np.ndarray): Gaussian normalization; calculated once for</dt>
<dd>efficiency</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="firefly_instrument.convolution_integral_element.error">
<code class="descname">error</code><span class="sig-paren">(</span><em>xc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#convolution_integral_element.error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.convolution_integral_element.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the error in the weighted mean of <code class="xref py py-attr docutils literal"><span class="pre">y</span></code> using
nominal error propagation.  The weights are defined by a
Gaussian with standard deviation <code class="xref py py-attr docutils literal"><span class="pre">sigma</span></code> and centered at
xc.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>xc (float): Center for the Gaussian weighting function</dd>
<dt>Returns:</dt>
<dd>float: The error in the weighted mean of <code class="xref py py-attr docutils literal"><span class="pre">y</span></code></dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="firefly_instrument.convolution_variable_sigma">
<code class="descclassname">firefly_instrument.</code><code class="descname">convolution_variable_sigma</code><span class="sig-paren">(</span><em>y</em>, <em>sigma</em>, <em>ye=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#convolution_variable_sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.convolution_variable_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve a discretely sampled function <span class="math">\(y(x)\)</span> with a Gaussian
kernel, <span class="math">\(g\)</span>, where the standard deviation of the kernel is a
function of <span class="math">\(x\)</span>, <span class="math">\(\sigma(x)\)</span>.  Nominal calculations can
be performed to propagate the error in the result; these
calculations <strong>do not</strong> include the covariance between the pixels,
which will mean that the calculations likely have significant error!</p>
<p>The convolution is defined as:</p>
<div class="math">
\[\begin{split}(y\ast g)(x) &amp;= \int_{-\infty}^{\infty} y(X)\ g(\sigma,x-X)\ dX \\
                         &amp;= \int_{-\infty}^{\infty} \frac{y(X)}{\sqrt{2\pi}\
                                \sigma(X)}\ \exp\left(-\frac{(x-X)^2}{2\
                                \sigma(X)^2}\right) dX .\end{split}\]</div>
<p>To minimize edge effects and account for the censoring of the data
(finite range in <span class="math">\(x\)</span>), the convolution is actually calculated
as a definite integral and normalized as follows:</p>
<div class="math">
\[(y\ast g)(x) \sim\frac{
\int_{x-n_\sigma*\sigma(x)}^{x+n_\sigma*\sigma(x)} y(X)\
g(\sigma,x-X)\ dX}{
\int_{x-n_\sigma*\sigma(x)}^{x+n_\sigma*\sigma(x)}
g(\sigma,x-X)\ dX} .\]</div>
<p>The above is identical to getting the weighted mean of <span class="math">\(y\)</span> at
each position <span class="math">\(x\)</span>, where the weights are defined by a Gaussian
kernel centered at <span class="math">\(x\)</span> with a variable dispersion.</p>
<dl class="docutils">
<dt>Use of this function requires:</dt>
<dd><ul class="first last simple">
<li><em>y</em> and <em>sigma</em> must be 1D vectors</li>
<li><em>y</em> and <em>sigma</em> must be uniformly sampled on the same grid</li>
<li><em>sigma</em> must be in pixel units.</li>
</ul>
</dd>
<dt>Args:</dt>
<dd><p class="first">y (np.ndarray): A uniformly sampled function to convolve.
sigma (np.ndarray): The standard deviation of the Gaussian</p>
<blockquote>
<div>kernel sampled at the same positions as <em>y</em>.  The units of
<em>sigma</em> <strong>must</strong> be in pixels.</div></blockquote>
<dl class="last docutils">
<dt>ye (np.ndarray): (Optional) Errors in the function</dt>
<dd><span class="math">\(y(x)\)</span>.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>np.ndarray: Arrays with the convolved function :math:<a href="#id1"><span class="problematic" id="id2">`</span></a>(yast</dt>
<dd>g)(x)` sampled at the same positions as the input <span class="math">\(x\)</span>
vector and its error.  The second array will be returned as
None if the error vector is not provided.</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd>Exception: Raised if trying to calculate the errors because they
haven&#8217;t been implemented yet.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="firefly_instrument.downgrade">
<code class="descclassname">firefly_instrument.</code><code class="descname">downgrade</code><span class="sig-paren">(</span><em>wave</em>, <em>flux</em>, <em>deltal_in</em>, <em>sigma_galaxy</em>, <em>wave_instrument</em>, <em>r_instrument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#downgrade"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.downgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Adapted from the manga DAP downgrader from Kyle Westfall.</p>
<p>Downgrades an input spectrum to a given galaxy velocity dispersion
using the input SEDs resolution and the resolution of the observation.</p>
<p>Returns flux of downgraded SED.</p>
</dd></dl>

<dl class="function">
<dt id="firefly_instrument.log_rebin">
<code class="descclassname">firefly_instrument.</code><code class="descname">log_rebin</code><span class="sig-paren">(</span><em>lamRange</em>, <em>spec</em>, <em>oversample=None</em>, <em>velscale=None</em>, <em>flux=False</em>, <em>log10=False</em>, <em>newRange=None</em>, <em>wave_in_ang=False</em>, <em>unobs=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#log_rebin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.log_rebin" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Copyright (C) 2001-2014, Michele Cappellari
E-mail: cappellari_at_astro.ox.ac.uk</p>
<p class="last">This software is provided as is without any warranty whatsoever.
Permission to use, for non-commercial purposes is granted.
Permission to modify for personal or internal use is granted,
provided this copyright and disclaimer are included unchanged at
the beginning of the file. All other rights are reserved.</p>
</div>
<p>Logarithmically rebin a spectrum, while rigorously conserving the
flux.  Basically the photons in the spectrum are simply
ridistributed according to a new grid of pixels, with non-uniform
size in the spectral direction.</p>
<p>This routine makes the <a href="#id3"><span class="problematic" id="id4">`</span></a>standard&#8217; zero-order assumption that the
spectrum is <em>constant</em> within each pixels. It is possible to perform
log-rebinning by assuming the spectrum is represented by a
piece-wise polynomial of higer degree, while still obtaining a
uniquely defined linear problem, but this reduces to a deconvolution
and amplifies noise.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This assumption can be poor for sharp features in the spectrum.
Beware if resampling spectra with strong, marginally sampled
features!</p>
</div>
<p>This same routine can be used to compute approximate errors of the
log-rebinned spectrum. To do this type the command</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">err2New</span><span class="p">,</span> <span class="n">logLam</span><span class="p">,</span> <span class="n">velscale</span> <span class="o">=</span> <span class="n">log_rebin</span><span class="p">(</span><span class="n">lamRange</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
</pre></div>
</div>
<p>and the desired errors will be given by np.sqrt(err2New).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This rebinning of the error-spectrum is very <em>approximate</em> as it
does not consider the correlation introduced by the rebinning!</p>
</div>
<p>Args:</p>
<blockquote>
<div><dl class="docutils">
<dt>lamRange (np.ndarray): two elements vector containing the</dt>
<dd>central wavelength of the first and last pixels in the
spectrum, which is assumed to have constant wavelength
scale! E.g. from the values in the standard FITS keywords:
LAMRANGE = CRVAL1 + [0,CDELT1*(NAXIS1-1)].  It must be
LAMRANGE[0] &lt; LAMRANGE[1].</dd>
</dl>
<p>spec (np.ndarray): Input spectrum.
oversample (int): (Optional) Oversampling can be done, not to</p>
<blockquote>
<div>loose spectral resolution, especally for extended wavelength
ranges and to avoid aliasing.  Default is to provide the
same number of output pixels as input.</div></blockquote>
<dl class="docutils">
<dt>velscale (float): Velocity scale in km/s per pixels. If this</dt>
<dd>variable is not defined, then it will contain in output the
velocity scale.  If this variable is defined by the user it
will be used to set the output number of pixels and
wavelength scale.</dd>
<dt>flux (bool): (Optional) Set this keyword to preserve total flux.</dt>
<dd><p class="first">In this case the log rebinning changes the pixels flux in
proportion to their dLam so the following command will show
large differences beween the spectral shape before and after
<a class="reference internal" href="#firefly_instrument.log_rebin" title="firefly_instrument.log_rebin"><code class="xref py py-func docutils literal"><span class="pre">log_rebin()</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Plot log-rebinned spectrum</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">logLam</span><span class="p">),</span> <span class="n">specNew</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lamRange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">lamRange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">spec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">spec</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p class="last">By default, when this keyword is <em>not</em> set, the above two
lines produce two spectra that almost perfectly overlap each
other.</p>
</dd>
<dt>log10 (bool): (Optional) Flag that the spectrum should be binned</dt>
<dd>in units of base-10 log wavelength, instead of natural log</dd>
<dt>newRange (np.ndarray): (Optional) Force the spectrum to be</dt>
<dd>sampled to a new spectral range (lamRange is the <em>existing</em>
spectral range).</dd>
<dt>wave_in_ang (bool): (Optional) Return the wavelength coordinates</dt>
<dd>in angstroms, not log(angstroms)</dd>
<dt>unobs (float): (Optional) Default value for unobserved spectral</dt>
<dd>regions.</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>np.ndarray, float</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">Returns three variables: logarithmically</span><dd>rebinned spectrum, the log of the wavelength at the
geometric center of each pixel, and the velocity scale of
each pixel in km/s.</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>ValueError: Raised if the input spectrum is not a</dt>
<dd>one-dimensional np.ndarray.</dd>
</dl>
</dd>
<dt><em>Modification History</em>:</dt>
<dd><div class="first last line-block">
<div class="line"><strong>V1.0.0</strong>: Using interpolation. Michele Cappellari, Leiden,
22 October 2001</div>
<div class="line"><strong>V2.0.0</strong>: Analytic flux conservation. MC, Potsdam, 15 June
2003</div>
<div class="line"><strong>V2.1.0</strong>: Allow a velocity scale to be specified by the
user.  MC, Leiden, 2 August 2003</div>
<div class="line"><strong>V2.2.0</strong>: Output the optional logarithmically spaced
wavelength at the geometric mean of the wavelength at the
border of each pixel.  Thanks to Jesus Falcon-Barroso. MC,
Leiden, 5 November 2003</div>
<div class="line"><strong>V2.2.1</strong>: Verify that lamRange[0] &lt; lamRange[1].  MC,
Vicenza, 29 December 2004</div>
<div class="line"><strong>V2.2.2</strong>: Modified the documentation after feedback from
James Price.  MC, Oxford, 21 October 2010</div>
<div class="line"><strong>V2.3.0</strong>: By default now preserve the shape of the spectrum,
not the total flux. This seems what most users expect from
the procedure.  Set the keyword /FLUX to preserve flux like
in previous version.  MC, Oxford, 30 November 2011</div>
<div class="line"><strong>V3.0.0</strong>: Translated from IDL into Python. MC, Santiago, 23
November 2013</div>
<div class="line"><strong>V3.1.0</strong>: Fully vectorized log_rebin. Typical speed up by
two orders of magnitude.  MC, Oxford, 4 March 2014</div>
<div class="line"><strong>05 Jun 2015</strong>: (K. Westfall, KBW) Pulled from ppxf_util.py.
Conform to mangadap documentation standard.  Transcribe
edits made to IDL version that provides for the log10 and
newRange arguments.  Add option to return wavelength in
angstroms, not log(angstroms).  Break out determination of
input and output spectrum pixel coordinates to a new
function, <a class="reference internal" href="#firefly_instrument.log_rebin_pix" title="firefly_instrument.log_rebin_pix"><code class="xref py py-func docutils literal"><span class="pre">log_rebin_pix()</span></code></a>.  Added default value for
unobserved pixels.  Default behavior unchanged.</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="firefly_instrument.log_rebin_pix">
<code class="descclassname">firefly_instrument.</code><code class="descname">log_rebin_pix</code><span class="sig-paren">(</span><em>lamRange</em>, <em>n</em>, <em>oversample=None</em>, <em>velscale=None</em>, <em>log10=False</em>, <em>newRange=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#log_rebin_pix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.log_rebin_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the number of new pixels and their coordinate step when
rebinning a spectrum in geometrically stepped bins.  The input
spectrum must be sampled linearly in wavelength.  This is primarily
a support routine for <a class="reference internal" href="#firefly_instrument.log_rebin" title="firefly_instrument.log_rebin"><code class="xref py py-func docutils literal"><span class="pre">log_rebin()</span></code></a>.</p>
<p>Although breaking this out from the main <a class="reference internal" href="#firefly_instrument.log_rebin" title="firefly_instrument.log_rebin"><code class="xref py py-func docutils literal"><span class="pre">log_rebin()</span></code></a> function
leads to a few repeat calculations in that function, the use of this
function is in determine a common wavelength range for a large
number of spectra before resampling the spectra themselves.  See
<code class="xref py py-class docutils literal"><span class="pre">mangadap.TplLibrary</span></code> .</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first docutils">
<dt>lamRange (np.ndarray): two elements vector containing the</dt>
<dd>central wavelength of the first and last pixels in the
spectrum, which is assumed to have constant wavelength
scale! E.g. from the values in the standard FITS keywords:
LAMRANGE = CRVAL1 + [0,CDELT1*(NAXIS1-1)].  It must be
LAMRANGE[0] &lt; LAMRANGE[1].</dd>
</dl>
<p>n (int): Number of pixels in the original spectrum.
oversample (int): (Optional) Oversampling can be done, not to</p>
<blockquote>
<div>loose spectral resolution, especally for extended wavelength
ranges and to avoid aliasing.  Default is to provide the
same number of output pixels as input.</div></blockquote>
<dl class="last docutils">
<dt>velscale (float): Velocity scale in km/s per pixels. If this</dt>
<dd>variable is not defined, then it will contain in output the
velocity scale.  If this variable is defined by the user it
will be used to set the output number of pixels and
wavelength scale.</dd>
<dt>log10 (bool): (Optional) Flag that the spectrum should be binned</dt>
<dd>in units of base-10 log wavelength, instead of natural log</dd>
<dt>newRange (np.ndarray): (Optional) Force the spectrum to be</dt>
<dd>sampled to a new spectral range (lamRange is the <em>existing</em>
spectral range).</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float, int</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">Returns (1) the linear wavelength step of each</span><dd>pixel in the input spectrum, (2) the number of pixels for
the rebinned spectrum, (3) the log-linear wavelength step
for each pixel in the new spectrum, (4) the velocity step
for each pixel in the new spectrum.</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>ValueError: Raised if the input wavelength range (<em>lamRange</em> or</dt>
<dd><em>newRange</em>) does not have two elements or is not sorted.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="firefly_instrument.match_spectral_resolution">
<code class="descclassname">firefly_instrument.</code><code class="descname">match_spectral_resolution</code><span class="sig-paren">(</span><em>wave</em>, <em>flux</em>, <em>sres</em>, <em>new_sres_wave</em>, <em>new_sres</em>, <em>ivar=None</em>, <em>mask=None</em>, <em>min_sig_pix=0.0</em>, <em>no_offset=True</em>, <em>variable_offset=False</em>, <em>log10=False</em>, <em>new_log10=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#match_spectral_resolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.match_spectral_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust the existing spectral resolution of to a <strong>lower</strong> resolution
as best as possible.  The primary functionality is in
<a class="reference internal" href="#firefly_instrument.spectral_resolution" title="firefly_instrument.spectral_resolution"><code class="xref py py-class docutils literal"><span class="pre">spectral_resolution</span></code></a>, which determines the Gaussian kernel
parameters needed to match the resolution, and
<code class="xref py py-func docutils literal"><span class="pre">convolve_variable_sigma()</span></code>, which actually performs the
convolution to match the resolution.</p>
<p>In particular, see
<a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">spectral_resolution.GaussianKernelDifference()</span></code></a> for a
description of how the kernel parameters are determined and how
regions where the target resolution is <strong>higher</strong> than the existing
resolution.  In this case, one of the options is to adopt an offset
of the resolution (in km/s) that could be corrected for in
subsequent analysis.  In this case, setting <em>variable_offset</em> to
True allows the offset to be different for all input spectra.  If
one expects to combine the spectra, the default behavior should be
used, forcing all the spectra to have a constant offset.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>wave (np.ndarray): A 1D or 2D (:math:<a href="#id5"><span class="problematic" id="id6">`</span></a>N_{rm spec}times</dt>
<dd>N_{rm pix}`) array with the wavelength in angstroms for a
set of spectra.  The sampling may be either in linear steps
of wavelength or <span class="math">\(\log_{10}\)</span> steps, as set using
<em>log10</em>.</dd>
<dt>flux (np.ndarray): A 1D or 2D (:math:<a href="#id7"><span class="problematic" id="id8">`</span></a>N_{rm spec}times</dt>
<dd>N_{rm pix}`) array with the flux sampled at the provided
wavelengths.</dd>
<dt>sres (np.ndarray): A 1D or 2D (:math:<a href="#id9"><span class="problematic" id="id10">`</span></a>N_{rm spec}times</dt>
<dd>N_{rm pix}`) array with the spectral resolution, <span class="math">\(R\)</span>,
at the provided wavelengths.</dd>
<dt>new_sres_wave (np.ndarray): A 1D vector with the wavelength</dt>
<dd>in angstroms at which the new resolution of the input
spectra has been sampled.  The sampling may be either in
linear steps of wavelength or <span class="math">\(\log_{10}\)</span> steps, as
set using <em>new_log10</em>.</dd>
<dt>new_sres (np.ndarray): A 1D vector with the new resolution</dt>
<dd>for the input spectra.</dd>
<dt>ivar (np.ndarray): (Optional) A 1D or 2D (:math:<a href="#id11"><span class="problematic" id="id12">`</span></a>N_{rm</dt>
<dd>spec}times N_{rm pix}`) array with the inverse variance of
the flux sampled at the provided wavelengths.  <strong>Currently
never used and, if provided, the output inverse variances
are simply a carbon copy of this array.</strong></dd>
<dt>mask (np.ndarray): (Optional) A 1D or 2D (:math:<a href="#id13"><span class="problematic" id="id14">`</span></a>N_{rm</dt>
<dd>spec}times N_{rm pix}`) array with a <em>uint</em> mask for the
flux sampled at the provided wavelengths.</dd>
<dt>no_offset (bool): (Optional) Force <span class="math">\(\sigma^2_{v,o} = 0\)</span> by</dt>
<dd>masking regions with <span class="math">\(\sigma_{p,d} &lt;
-\epsilon_\sigma\)</span>; i.e., the value of this arguments selects
Option 1 (True) or Option 2 (False).  See
<a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">spectral_resolution.GaussianKernelDifference()</span></code></a>.</dd>
<dt>min_sig_pix (float): (Optional) Minimum value of the standard</dt>
<dd>deviation in pixels allowed before assuming the kernel is a
Delta function.</dd>
<dt>variable_offset (bool): (Optional) Flag to allow the offset</dt>
<dd>applied to each spectrum (when the input contains more than
one spectraum) to be tailored to each spectrum.  Otherwise
(<em>variable_offset=False</em>) the offset is forced to be the
same for all spectra.</dd>
<dt>log10 (bool): (Optional) Flag that the spectrum has been binned</dt>
<dd>logarithmically (base 10) in wavelength</dd>
<dt>new_log10 (bool): (Optional) Flag that the coordinates of the</dt>
<dd>new spectral resolution are  spectrum as been binned
logarithmically (base 10) in wavelength.</dd>
</dl>
</dd>
</dl>
<p>Returns:</p>
<blockquote>
<div><p>np.ndarray : Four or Five arrays are returned:</p>
<blockquote>
<div><ul class="simple">
<li>A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm pix}\)</span>) array
with the resolution-matched flux sampled at the input
wavelengths.</li>
<li>A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm pix}\)</span>) array
with the spectral resolution, <span class="math">\(R\)</span>, of the
resolution-matched spectra at the provided wavelengths.</li>
<li>A 1D vector with any constant offset in resolution <strong>in
km/s</strong> between the targetted value and the result.  See
<a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">spectral_resolution.GaussianKernelDifference()</span></code></a>.</li>
<li>A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm pix}\)</span>) array
with a <em>uint</em> mask for the resolution-matched flux sampled
at the input wavelengths.  This is returned regardless of
whether an input mask was provided.  Any pixel that had a
resolution that was lower than the target resolution (up
to some tolerance defined by <em>min_sig_pix</em>) is returned as
masked.</li>
<li>(Optional) A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm
pix}\)</span>) array with the inverse variance of the
resolution-matched flux sampled at the input wavelengths.
<strong>Only output if *ivar* is provided, and in that case this
is just a carbon copy of the input array.</strong></li>
</ul>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Raises:</dt>
<dd><p class="first">Exception: Raised if:</p>
<blockquote class="last">
<div><ul class="simple">
<li>the input <em>wave</em> array is 2D and the <em>sres</em> array is not;
a 1D wavelength array is allowed for a 2D <em>sres</em> array but
not vice versa</li>
<li>the number of spectral pixels in <em>wave</em>, <em>flux</em>, and
<em>sres</em> is not the same</li>
<li>the shape of the <em>flux</em>, <em>mask</em> (if provided), and <em>ivar</em>
(if provided) are not the same</li>
<li>the shape of the <em>new_sres_wave</em> and <em>new_sres</em> arrays
are not the same and/or not 1D</li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="firefly_instrument.spectral_resolution">
<em class="property">class </em><code class="descclassname">firefly_instrument.</code><code class="descname">spectral_resolution</code><span class="sig-paren">(</span><em>wave</em>, <em>sres</em>, <em>log10=False</em>, <em>interp_ext='extrapolate'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Container class for the resolution, <span class="math">\(R =
\lambda/\Delta\lambda\)</span>, of a spectrum.  The primary functionality is
to determine the parameters necessary to match the resolution of one
spectrum to another.  It can also be used as a function to
interpolate the spectral resolution at a given wavelenth.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>wave (np.ndarray): A 1D vector with the wavelength in</dt>
<dd>angstroms.  The sampling may be either in linear steps of
wavelength or <span class="math">\(\log_{10}\)</span> steps.</dd>
<dt>sres (np.ndarray): A 1D vector with the spectral resolution,</dt>
<dd><span class="math">\(R\)</span>, sampled at the positions of the provided
wavelength vector.</dd>
<dt>log10 (bool): (Optional) Flag that the spectrum has been binned</dt>
<dd>logarithmically (base 10) in wavelength</dd>
<dt>interp_ext (int or str): (Optional) The value to pass as <em>ext</em></dt>
<dd>to the interpolator, which defines its behavior when
attempting to sample the spectral resolution beyond where it
is defined.  See
<a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html">scipy.interpolate.InterpolatedUnivariateSpline</a>.  Default
is to extrapolate.</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>Exception: Raised if <em>wave</em> is not a 1D vector or if <em>wave</em> and</dt>
<dd><em>sres</em> do not have the same shape.</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first docutils">
<dt>interpolator</dt>
<dd>(<a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html">scipy.interpolate.InterpolatedUnivariateSpline</a>): An
object used to interpolate the spectral resolution at any
given wavelength.  The interpolation is hard-wired to be
<strong>linear</strong> and its extrapolation behavior is defined by
<em>interp_ext</em>.  The wavelength and resolution vectors are
held by this object for later reference if needed.</dd>
<dt>log10 (bool): Flag that the spectrum has been binned</dt>
<dd>logarithmically (base 10) in wavelength</dd>
<dt>cnst (<code class="xref py py-class docutils literal"><span class="pre">mangadap.util.constants</span></code>): Used to define the</dt>
<dd>conversion factor between a Gaussian sigma and FWHM</dd>
</dl>
<p>c (float): The speed of light; provided by <a class="reference external" href="http://docs.astropy.org/en/stable/constants/index.html">astropy.constants</a>.
dv (float): The velocity step per pixel in km/s.  Defined using</p>
<blockquote>
<div><a class="reference internal" href="#firefly_instrument.spectrum_velocity_scale" title="firefly_instrument.spectrum_velocity_scale"><code class="xref py py-func docutils literal"><span class="pre">spectrum_velocity_scale()</span></code></a> if <code class="xref py py-attr docutils literal"><span class="pre">log10</span></code> is True;
otherwise set to None.</div></blockquote>
<dl class="last docutils">
<dt>dw (float): The wavelength step per pixel in angstroms.  Defined</dt>
<dd>as the wavelength step between the first two pixels if
<code class="xref py py-attr docutils literal"><span class="pre">log10</span></code> is False; otherwise set to None.</dd>
<dt>min_sig (float): Minimum standard deviation allowed for the</dt>
<dd>kernel used to match two spectral resolutions.  See
<a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</dd>
<dt>sig_pd (np.ndarray): The standard deviation in pixels</dt>
<dd>required to match the spectral resolution of this object to
the resolution defined by a different spectral_resolution
object.  See <a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</dd>
<dt>sig_mask (np.ndarray): A <em>uint</em> vector used to identify</dt>
<dd>measurements of <code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code> that should <strong>not</strong> be used
to match the spectral resolution of this object to the
resolution defined by a different spectral_resolution
object.  See <a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</dd>
<dt>sig_vo (float): A constant offset of the kernal standard</dt>
<dd>deviation <strong>in km/s</strong> that has been applied to
<code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code>.  See <a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</dd>
</dl>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The default behavior of the interpolator is to extrapolate the
input spectral resolution vector when trying to sample from
regions beyond where it is sampled.  Use <em>interp_ext</em> change
this; see <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html">scipy.interpolate.InterpolatedUnivariateSpline</a>.</p>
</div>
<dl class="method">
<dt id="firefly_instrument.spectral_resolution.GaussianKernelDifference">
<code class="descname">GaussianKernelDifference</code><span class="sig-paren">(</span><em>new_sres</em>, <em>no_offset=True</em>, <em>min_sig_pix=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.GaussianKernelDifference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the parameters of a Gaussian kernel required to
convert the resolution of this object to the resolution of a
different the <a class="reference internal" href="#firefly_instrument.spectral_resolution" title="firefly_instrument.spectral_resolution"><code class="xref py py-class docutils literal"><span class="pre">spectral_resolution</span></code></a> object, <em>new_sres</em>.</p>
<p>The spectral resolution is defined as <span class="math">\(R =
\lambda/\Delta\lambda\)</span>, where <span class="math">\(\Delta\lambda\)</span> is the FWHM
of the spectral resolution element.  The standard deviation of
the resolution element in angstroms is then</p>
<div class="math">
\[\sigma_\lambda = \frac{\lambda}{f R}, \ \ {\rm where} \ \  f
= \frac{{\rm FWHM_\lambda}}{\sigma_\lambda}.\]</div>
<p>Assuming a Gaussian (in angstroms) line-spread function:</p>
<div class="math">
\[\sigma^2_{\lambda,2} = \sigma^2_{\lambda,1} +
\sigma^2_{\lambda,d}\]</div>
<p>such that</p>
<div class="math">
\[\sigma^2_{\lambda,d} = \left(\frac{\lambda}{f}\right)^2
(R^{-2}_2 - R^{-2}_1)\]</div>
<p>is the defining parameter of the Gaussian kernel needed to take
a spectrum of resolution <span class="math">\(R_1\)</span> to one with a resolution of
<span class="math">\(R_2\)</span>.</p>
<p>For input to <a class="reference internal" href="#firefly_instrument.convolution_variable_sigma" title="firefly_instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a>, the
<em>wavelength-dependent</em> parameter of the Gaussian kernel is
converted to pixels.  This function allows for the input spectra
to be linearly sampled in angstroms or log10(angstroms).  For
the former (<em>log10=False</em>),</p>
<div class="math">
\[\sigma^2_{p,d} = \left(\frac{\lambda}{f\
\delta\lambda}\right)^2 (R^{-2}_2 - R^{-2}_1)\]</div>
<p>where <span class="math">\(\delta\lambda\)</span> is the size of the pixel in
angstroms.  If the units are log10(angstrom) (<em>log10=True</em>), we
approximate the velocity width of each pixel to be <span class="math">\(\delta
v = c \ln(10.0) (\log\lambda[1]-\log\lambda[0])\)</span>, such that</p>
<div class="math">
\[\begin{split}\sigma^2_{p,d} &amp;= \left(\frac{c}{ \delta v \lambda}\right)^2
\sigma^2_{\lambda,d} \\ &amp;= \left(\frac{c}{ f\ \delta
v}\right)^2 (R^{-2}_2 - R^{-2}_1)\ ;\end{split}\]</div>
<p><span class="math">\(c\)</span> is the speed of light in km/s.</p>
<p>The nominal use of this algorithm assumes <span class="math">\(R_1 \geq R_2\)</span>.
However, in practice, <a class="reference internal" href="#firefly_instrument.convolution_variable_sigma" title="firefly_instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a> only
uses a Gaussian kernel up to some minimum value of
<span class="math">\(\epsilon_\sigma\)</span>; below this, the kernel is assumed to be
a Delta function.  Therefore, as long as</p>
<div class="math">
\[\sigma_{p,d} \equiv \sigma^2_{p,d}/\sqrt{|\sigma^2_{p,d}|}
\geq -\epsilon_\sigma\ ,\]</div>
<p>the behavior of <a class="reference internal" href="#firefly_instrument.convolution_variable_sigma" title="firefly_instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a> should not be
affected.</p>
<p>Even so, there may be spectral regions that do not have
<span class="math">\(\sigma_{p,d} \geq -\epsilon_\sigma\)</span>; for such spectral
regions there are three choices:</p>
<blockquote>
<div><p>(<strong>Option 1</strong>) trim the spectral range to only those
spectral regions where the existing resolution is better
than the target resolution,</p>
<p>(<strong>Option 2</strong>) match the existing resolution to the target
resolution up to some constant offset that must be accounted
for in subsequent analyses, or</p>
<p>(<strong>Option 3</strong>) allow for a wavelength dependent difference
in the spectral resolution that must be accounted for in
subsequent analyses.</p>
</div></blockquote>
<p>The choice of either Option 1 or 2 is selected by setting
<em>no_offset</em> to, respectively, True or False; Option 1 is the
default behavior.  Currently, Option 3 is not allowed.</p>
<p>For Option 1, pixels with <span class="math">\(\sigma_{p,d} &lt;
-\epsilon_\sigma\)</span> are masked (<em>sigma_mask = 1</em>); however, the
returned values of <span class="math">\(\sigma_{p,d}\)</span> are left unchanged.</p>
<p>For Option 2, we define</p>
<div class="math">
\[\sigma^2_{v,o} = -{\rm min}(\sigma^2_{v,d}) - {\rm
max}(\epsilon_\sigma \delta v)^2\]</div>
<p>where <span class="math">\(\delta v\)</span> is constant for the logarithmically
binned spectrum and is wavelength dependent for the linearly
binned spectra; in the latter case, the velocity step is
determined for each pixel:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">_wave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">()</span>
<span class="n">dv</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>If <span class="math">\(\sigma^2_{v,o} &gt; 0.0\)</span>, it must be that <span class="math">\({\rm
min}(\sigma^2_{v,d}) &lt; -{\rm max}(\epsilon_\sigma \delta v)^2\)</span>,
such that an offset should be applied.  In that case, the
returned kernel parameters are</p>
<div class="math">
\[\sigma^\prime_{v,d} = \sqrt{\sigma^2_{v,d} +
\sigma^2_{v,o}}\ .\]</div>
<p>with the units converted to pixels using the equations above, no
pixels are masked, and <span class="math">\(\sqrt{\sigma^2_{v,o}}\)</span> is returned
for the offset.  Otherwise, the offset is set to 0.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>new_sres (<a class="reference internal" href="#firefly_instrument.spectral_resolution" title="firefly_instrument.spectral_resolution"><code class="xref py py-class docutils literal"><span class="pre">spectral_resolution</span></code></a>): Spectral resolution</dt>
<dd>to match to.</dd>
<dt>no_offset (bool): (Optional) Force :math:<a href="#id15"><span class="problematic" id="id16">`</span></a>sigma^2_{v,o} =</dt>
<dd>0` by masking regions with <span class="math">\(\sigma_{p,d} &lt;
-\epsilon_\sigma\)</span>; i.e., the value of this arguments
selects Option 1 (True) or Option 2 (False).</dd>
<dt>min_sig_pix (float): (Optional) Minimum value of the</dt>
<dd>standard deviation allowed before assuming the kernel is
a Delta function.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="firefly_instrument.spectral_resolution.adjusted_resolution">
<code class="descname">adjusted_resolution</code><span class="sig-paren">(</span><em>indx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.adjusted_resolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.adjusted_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the resolution that should result from applying
<a class="reference internal" href="#firefly_instrument.convolution_variable_sigma" title="firefly_instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a> to the spectrum associated
with this spectral resolution object using <code class="xref py py-attr docutils literal"><span class="pre">sigma_pd</span></code>.
I.e., calculate:</p>
<div class="math">
\[R_2 = \left[ \left(\frac{f}{c}\right)^2 \sigma^2_{v,d} +
R^{-2}_1\right]^{-1/2}\ . \]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>indx (tuple): (Optional) Selection tuple used to return a</dt>
<dd>subset of the full resolution vector.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>np.ndarray: The (full or selected) vector with the</dt>
<dd>adjusted resolution.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="firefly_instrument.spectral_resolution.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>new_sres</em>, <em>no_offset=True</em>, <em>min_sig_pix=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Currently only an alias for <a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="firefly_instrument.spectral_resolution.offset_GaussianKernelDifference">
<code class="descname">offset_GaussianKernelDifference</code><span class="sig-paren">(</span><em>offset</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.offset_GaussianKernelDifference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.offset_GaussianKernelDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>If the properties required to match the resolution of one
spectrum to another has already been calculated (see
<a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>), this allows for one to apply
an additional offset.  The additional offset <strong>must</strong> be in km/s
(not pixels).</p>
<p>The offset is applied in quadrature; however, the offset can be
negative such that one can reduce <code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code>.  Once
converted to km/s, the offset is applied by calculating:</p>
<div class="math">
\[\sigma^{\prime\ 2}_{v,d} = \sigma^{2}_{v,d} +
\sigma_{off}|\sigma_{off}|\ .\]</div>
<p><code class="xref py py-attr docutils literal"><span class="pre">sig_vo</span></code> is adjusted in the same way, and the change in
<span class="math">\(\sigma^{\prime\ 2}_{v,d}\)</span> is then propagated to
<code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">sig_mask</span></code>.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>offset (float): Value of the standard deviation in km/s to</dt>
<dd>add in quadrature to a previously calculated
<code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code>.</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>Exception: Raised if the kernel properties have not yet been</dt>
<dd>defined.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="firefly_instrument.spectral_resolution.sres">
<code class="descname">sres</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.sres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.sres" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the resolution vector; held by <code class="xref py py-attr docutils literal"><span class="pre">interpolator</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="firefly_instrument.spectral_resolution.wave">
<code class="descname">wave</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.wave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.wave" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the wavelength vector; held by <code class="xref py py-attr docutils literal"><span class="pre">interpolator</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="firefly_instrument.spectrum_velocity_scale">
<code class="descclassname">firefly_instrument.</code><code class="descname">spectrum_velocity_scale</code><span class="sig-paren">(</span><em>wave</em>, <em>log10=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectrum_velocity_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectrum_velocity_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the velocity sampling of an input wavelength coordinate
vector.  The wavelength vector is assumed to be logarithmically
sampled, but its units are in angstroms.</p>
<dl class="docutils">
<dt>Args: </dt>
<dd><dl class="first last docutils">
<dt>wave (np.ndarray): Wavelength coordinates of each spectral</dt>
<dd>channel in angstroms.  It is expected that the spectrum has
been sampled geometrically.</dd>
<dt>log10 (bool): (Optional) Input spectrum has been sample</dt>
<dd>geometrically using the base 10 logarithm, instead of the
natural logarithm.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>float : Velocity scale of the spectrum in km/s.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="firefly_instrument.where_not">
<code class="descclassname">firefly_instrument.</code><code class="descname">where_not</code><span class="sig-paren">(</span><em>indx</em>, <em>size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#where_not"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.where_not" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple with the indices of a vector that were <em>not</em> selected
by a call to <a href="#id17"><span class="problematic" id="id18">`np.where`_</span></a>.  <strong>The function currently only works
for 1D vectors.</strong></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>indx (tuple): Tuple returned by a call to <a href="#id19"><span class="problematic" id="id20">`np.where`_</span></a> for a</dt>
<dd>1D vector.</dd>
<dt>size (int): Length of the original vector in the call to</dt>
<dd><a href="#id21"><span class="problematic" id="id22">`np.where`_</span></a>.</dd>
</dl>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Performs <strong>no</strong> checks of the input.</p>
</div>
</dd></dl>

</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="firefly_fitter.html">firefly fitter</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="firefly_library.html">firefly library</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, johan comparat.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>