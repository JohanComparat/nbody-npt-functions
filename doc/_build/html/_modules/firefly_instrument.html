<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>firefly_instrument &#8212; pySU, python Skies and Universes 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pySU, python Skies and Universes 1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>pySU, python Skies and Universes 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>firefly_instrument</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for firefly_instrument</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Provides a set of functions to handle instrumental effects.</span>

<span class="sd">:func:`log_rebin` has been pulled from</span>
<span class="sd">:mod:`mangadap.contrib.ppxf_util.py` and modified.</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/util/instrument.py</span>

<span class="sd">*Python2/3 compliance*::</span>

<span class="sd">    from __future__ import division</span>
<span class="sd">    from __future__ import print_function</span>
<span class="sd">    from __future__ import absolute_import</span>
<span class="sd">    </span>
<span class="sd">    import sys</span>
<span class="sd">    if sys.version &gt; &#39;3&#39;:</span>
<span class="sd">        long = int</span>

<span class="sd">*Imports*::</span>

<span class="sd">    import warnings</span>
<span class="sd">    import numpy</span>
<span class="sd">    from scipy.interpolate import InterpolatedUnivariateSpline</span>
<span class="sd">    import astropy.constants</span>

<span class="sd">*Revision history*:</span>
<span class="sd">    | **27 May 2015**: Original implementation by K. Westfall (KBW)</span>
<span class="sd">        based on downgrader_MANGA.f provided by D. Thomas, O. Steele, D.</span>
<span class="sd">        Wilkinson, D. Goddard.</span>
<span class="sd">        13 June 2015: D.Wilkinson edit to not calculate unimportant</span>
<span class="sd">                        convolution terms -&gt; runs 5x faster.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">InterpolatedUnivariateSpline</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">astropy.constants</span> <span class="k">import</span> <span class="n">c</span> <span class="k">as</span> <span class="n">speedOfLight</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">speedOfLight</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

<div class="viewcode-block" id="where_not"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.where_not">[docs]</a><span class="k">def</span> <span class="nf">where_not</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Return a tuple with the indices of a vector that were *not* selected</span>
<span class="sd">	by a call to `np.where`_.  **The function currently only works</span>
<span class="sd">	for 1D vectors.**</span>

<span class="sd">	Args:</span>
<span class="sd">		indx (tuple): Tuple returned by a call to `np.where`_ for a</span>
<span class="sd">			1D vector.</span>
<span class="sd">		size (int): Length of the original vector in the call to</span>
<span class="sd">			`np.where`_.</span>

<span class="sd">	.. warning:: </span>
<span class="sd">		Performs **no** checks of the input.</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">size</span><span class="p">),</span> <span class="n">indx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),)</span></div>
    
<div class="viewcode-block" id="spectrum_velocity_scale"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectrum_velocity_scale">[docs]</a><span class="k">def</span> <span class="nf">spectrum_velocity_scale</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Determine the velocity sampling of an input wavelength coordinate</span>
<span class="sd">	vector.  The wavelength vector is assumed to be logarithmically</span>
<span class="sd">	sampled, but its units are in angstroms.</span>

<span class="sd">	Args: </span>
<span class="sd">		wave (np.ndarray): Wavelength coordinates of each spectral</span>
<span class="sd">			channel in angstroms.  It is expected that the spectrum has</span>
<span class="sd">			been sampled geometrically.</span>
<span class="sd">		log10 (bool): (Optional) Input spectrum has been sample</span>
<span class="sd">			geometrically using the base 10 logarithm, instead of the</span>
<span class="sd">			natural logarithm.</span>

<span class="sd">	Returns:</span>
<span class="sd">		float : Velocity scale of the spectrum in km/s.</span>

<span class="sd">	&quot;&quot;&quot;</span>

	<span class="n">dl_over_l</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">wave</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span> <span class="k">if</span> <span class="n">log10</span> <span class="k">else</span> \
				<span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">wave</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">wave</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
				
	<span class="k">return</span> <span class="n">c</span><span class="o">*</span><span class="n">dl_over_l</span></div>


<div class="viewcode-block" id="convolution_integral_element"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.convolution_integral_element">[docs]</a><span class="k">class</span> <span class="nc">convolution_integral_element</span><span class="p">:</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Support class for variable sigma convolution.  See</span>
<span class="sd">	:func:`convolution_variable_sigma`.</span>

<span class="sd">	Args:</span>
<span class="sd">		y (np.ndarray): Vector to convolve</span>
<span class="sd">		sigma (np.ndarray): Coordinate-dependent standard deviation of the</span>
<span class="sd">			Gaussian kernel</span>
<span class="sd">		ye (np.ndarray): (Optional) Error in the vector to convolve</span>

<span class="sd">	Raises:</span>
<span class="sd">		Exception: Raised if *y* is not a 1D vector, or if the shape of</span>
<span class="sd">			*y* and *sigma* (and *ye* if provided) are different.</span>

<span class="sd">	Attributes:</span>
<span class="sd">		x (np.ndarray): Pixel coordinate vector</span>
<span class="sd">		y (np.ndarray): Vector to convolve</span>
<span class="sd">		ye (np.ndarray): Error in the vector to convolve</span>
<span class="sd">		sigma (np.ndarray): Coordinate-dependent standard deviation of the</span>
<span class="sd">			Gaussian kernel</span>
<span class="sd">		norm (np.ndarray): Gaussian normalization; calculated once for</span>
<span class="sd">			efficiency</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">ye</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;y must be a 1D array!&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;y and sigma must have the same shape!&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">ye</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ye</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;y and ye must have the same shape!&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ye</span> <span class="o">=</span> <span class="n">ye</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>


	<span class="k">def</span> <span class="nf">_get_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xc</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Calculate the kernel vector when centered at *xc*.&quot;&quot;&quot;</span>
		<span class="n">div</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span> 
		<span class="n">close_value</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">div</span> <span class="o">&lt;</span> <span class="mf">50.0</span><span class="p">)</span>
		<span class="n">outkern</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">div</span><span class="p">[</span><span class="n">close_value</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[</span><span class="n">close_value</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">close_value</span><span class="p">,</span><span class="n">outkern</span>

	<span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xc</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the weighted mean of :attr:`y`, where the weights are</span>
<span class="sd">		defined by a Gaussian with standard deviation :attr:`sigma` and</span>
<span class="sd">		centered at xc.</span>

<span class="sd">		Args:</span>
<span class="sd">			xc (float): Center for the Gaussian weighting function</span>

<span class="sd">		Returns:</span>
<span class="sd">			float: The weighted mean of :attr:`y`</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">close_array</span><span class="p">,</span><span class="n">kernel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_kernel</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">close_array</span><span class="p">]</span><span class="o">*</span><span class="n">kernel</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>


<div class="viewcode-block" id="convolution_integral_element.error"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.convolution_integral_element.error">[docs]</a>	<span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xc</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the error in the weighted mean of :attr:`y` using</span>
<span class="sd">		nominal error propagation.  The weights are defined by a</span>
<span class="sd">		Gaussian with standard deviation :attr:`sigma` and centered at</span>
<span class="sd">		xc.</span>

<span class="sd">		Args:</span>
<span class="sd">			xc (float): Center for the Gaussian weighting function</span>

<span class="sd">		Returns:</span>
<span class="sd">			float: The error in the weighted mean of :attr:`y`</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">kernel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_kernel</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ye</span><span class="o">*</span><span class="n">kernel</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="convolution_variable_sigma"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.convolution_variable_sigma">[docs]</a><span class="k">def</span> <span class="nf">convolution_variable_sigma</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">ye</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">	Convolve a discretely sampled function :math:`y(x)` with a Gaussian</span>
<span class="sd">	kernel, :math:`g`, where the standard deviation of the kernel is a</span>
<span class="sd">	function of :math:`x`, :math:`\sigma(x)`.  Nominal calculations can</span>
<span class="sd">	be performed to propagate the error in the result; these</span>
<span class="sd">	calculations **do not** include the covariance between the pixels,</span>
<span class="sd">	which will mean that the calculations likely have significant error!</span>

<span class="sd">	The convolution is defined as:</span>

<span class="sd">	.. math::</span>

<span class="sd">		(y\ast g)(x) &amp;= \int_{-\infty}^{\infty} y(X)\ g(\sigma,x-X)\ dX \\</span>
<span class="sd">					 &amp;= \int_{-\infty}^{\infty} \frac{y(X)}{\sqrt{2\pi}\</span>
<span class="sd">						\sigma(X)}\ \exp\left(-\frac{(x-X)^2}{2\</span>
<span class="sd">						\sigma(X)^2}\right) dX .</span>

<span class="sd">	To minimize edge effects and account for the censoring of the data</span>
<span class="sd">	(finite range in :math:`x`), the convolution is actually calculated</span>
<span class="sd">	as a definite integral and normalized as follows:</span>

<span class="sd">	.. math::</span>

<span class="sd">		(y\ast g)(x) \sim\frac{</span>
<span class="sd">		\int_{x-n_\sigma*\sigma(x)}^{x+n_\sigma*\sigma(x)} y(X)\</span>
<span class="sd">		g(\sigma,x-X)\ dX}{</span>
<span class="sd">		\int_{x-n_\sigma*\sigma(x)}^{x+n_\sigma*\sigma(x)}</span>
<span class="sd">		g(\sigma,x-X)\ dX} .</span>

<span class="sd">	The above is identical to getting the weighted mean of :math:`y` at</span>
<span class="sd">	each position :math:`x`, where the weights are defined by a Gaussian</span>
<span class="sd">	kernel centered at :math:`x` with a variable dispersion.</span>

<span class="sd">	Use of this function requires:</span>
<span class="sd">		- *y* and *sigma* must be 1D vectors</span>
<span class="sd">		- *y* and *sigma* must be uniformly sampled on the same grid</span>
<span class="sd">		- *sigma* must be in pixel units.</span>

<span class="sd">	Args:</span>
<span class="sd">		y (np.ndarray): A uniformly sampled function to convolve.</span>
<span class="sd">		sigma (np.ndarray): The standard deviation of the Gaussian</span>
<span class="sd">			kernel sampled at the same positions as *y*.  The units of</span>
<span class="sd">			*sigma* **must** be in pixels.</span>
<span class="sd">		ye (np.ndarray): (Optional) Errors in the function</span>
<span class="sd">			:math:`y(x)`.</span>

<span class="sd">	Returns:</span>
<span class="sd">		np.ndarray: Arrays with the convolved function :math:`(y\ast</span>
<span class="sd">			g)(x)` sampled at the same positions as the input :math:`x`</span>
<span class="sd">			vector and its error.  The second array will be returned as</span>
<span class="sd">			None if the error vector is not provided.</span>

<span class="sd">	Raises:</span>
<span class="sd">		Exception: Raised if trying to calculate the errors because they</span>
<span class="sd">		haven&#39;t been implemented yet.</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">kernel</span>  <span class="o">=</span> <span class="n">convolution_integral_element</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">ye</span><span class="o">=</span><span class="n">ye</span><span class="p">)</span>
	<span class="n">conv</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">x</span><span class="p">)))</span>

	<span class="k">if</span> <span class="n">ye</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">conv</span>

	<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">x</span><span class="p">)))</span>
	<span class="k">return</span> <span class="n">conv</span><span class="p">,</span> <span class="n">out</span></div>


<div class="viewcode-block" id="spectral_resolution"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution">[docs]</a><span class="k">class</span> <span class="nc">spectral_resolution</span><span class="p">:</span>
	<span class="sd">r&quot;&quot;&quot;</span>

<span class="sd">	Container class for the resolution, :math:`R =</span>
<span class="sd">	\lambda/\Delta\lambda`, of a spectrum.  The primary functionality is</span>
<span class="sd">	to determine the parameters necessary to match the resolution of one</span>
<span class="sd">	spectrum to another.  It can also be used as a function to</span>
<span class="sd">	interpolate the spectral resolution at a given wavelenth.</span>

<span class="sd">	Args:</span>
<span class="sd">		wave (np.ndarray): A 1D vector with the wavelength in</span>
<span class="sd">			angstroms.  The sampling may be either in linear steps of</span>
<span class="sd">			wavelength or :math:`\log_{10}` steps.</span>
<span class="sd">		sres (np.ndarray): A 1D vector with the spectral resolution,</span>
<span class="sd">			:math:`R`, sampled at the positions of the provided</span>
<span class="sd">			wavelength vector.</span>
<span class="sd">		log10 (bool): (Optional) Flag that the spectrum has been binned</span>
<span class="sd">			logarithmically (base 10) in wavelength</span>
<span class="sd">		interp_ext (int or str): (Optional) The value to pass as *ext*</span>
<span class="sd">			to the interpolator, which defines its behavior when</span>
<span class="sd">			attempting to sample the spectral resolution beyond where it</span>
<span class="sd">			is defined.  See</span>
<span class="sd">			`scipy.interpolate.InterpolatedUnivariateSpline`_.  Default</span>
<span class="sd">			is to extrapolate.</span>

<span class="sd">	Raises:</span>
<span class="sd">		Exception: Raised if *wave* is not a 1D vector or if *wave* and</span>
<span class="sd">			*sres* do not have the same shape.</span>

<span class="sd">	Attributes:</span>
<span class="sd">		interpolator</span>
<span class="sd">			(`scipy.interpolate.InterpolatedUnivariateSpline`_): An</span>
<span class="sd">			object used to interpolate the spectral resolution at any</span>
<span class="sd">			given wavelength.  The interpolation is hard-wired to be</span>
<span class="sd">			**linear** and its extrapolation behavior is defined by</span>
<span class="sd">			*interp_ext*.  The wavelength and resolution vectors are</span>
<span class="sd">			held by this object for later reference if needed.</span>
<span class="sd">		log10 (bool): Flag that the spectrum has been binned</span>
<span class="sd">			logarithmically (base 10) in wavelength</span>
<span class="sd">		cnst (:class:`mangadap.util.constants`): Used to define the</span>
<span class="sd">			conversion factor between a Gaussian sigma and FWHM</span>
<span class="sd">		c (float): The speed of light; provided by `astropy.constants`_.</span>
<span class="sd">		dv (float): The velocity step per pixel in km/s.  Defined using</span>
<span class="sd">			:func:`spectrum_velocity_scale` if :attr:`log10` is True;</span>
<span class="sd">			otherwise set to None.</span>
<span class="sd">		dw (float): The wavelength step per pixel in angstroms.  Defined</span>
<span class="sd">			as the wavelength step between the first two pixels if</span>
<span class="sd">			:attr:`log10` is False; otherwise set to None.</span>
<span class="sd">		min_sig (float): Minimum standard deviation allowed for the</span>
<span class="sd">			kernel used to match two spectral resolutions.  See</span>
<span class="sd">			:func:`GaussianKernelDifference`.</span>
<span class="sd">		sig_pd (np.ndarray): The standard deviation in pixels</span>
<span class="sd">			required to match the spectral resolution of this object to</span>
<span class="sd">			the resolution defined by a different spectral_resolution</span>
<span class="sd">			object.  See :func:`GaussianKernelDifference`.</span>
<span class="sd">		sig_mask (np.ndarray): A *uint* vector used to identify</span>
<span class="sd">			measurements of :attr:`sig_pd` that should **not** be used</span>
<span class="sd">			to match the spectral resolution of this object to the</span>
<span class="sd">			resolution defined by a different spectral_resolution</span>
<span class="sd">			object.  See :func:`GaussianKernelDifference`.</span>
<span class="sd">		sig_vo (float): A constant offset of the kernal standard</span>
<span class="sd">			deviation **in km/s** that has been applied to</span>
<span class="sd">			:attr:`sig_pd`.  See :func:`GaussianKernelDifference`.</span>
<span class="sd">		</span>
<span class="sd">	.. todo::</span>

<span class="sd">		- Allow it to determine if the binning is linear or geometric,</span>
<span class="sd">		  then use the *log10* keyword to distinguish between natural</span>
<span class="sd">		  log and :math:`log_{10}` binning.</span>
<span class="sd">		- Allow for more than one type of line-spread function?</span>

<span class="sd">	.. warning::</span>

<span class="sd">		The default behavior of the interpolator is to extrapolate the</span>
<span class="sd">		input spectral resolution vector when trying to sample from</span>
<span class="sd">		regions beyond where it is sampled.  Use *interp_ext* change</span>
<span class="sd">		this; see `scipy.interpolate.InterpolatedUnivariateSpline`_.</span>

<span class="sd">	.. _scipy.interpolate.InterpolatedUnivariateSpline: http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html</span>
<span class="sd">	.. _astropy.constants: http://docs.astropy.org/en/stable/constants/index.html </span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interp_ext</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">):</span>
		<span class="c1"># Check the sizes</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;wave must be a 1D array!&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;wave and sres must have the same shape!&#39;</span><span class="p">)</span>

		<span class="c1"># k=1; always use linear interpolation</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span> <span class="o">=</span> <span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">interp_ext</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log10</span> <span class="o">=</span> <span class="n">log10</span>
		<span class="c1"># Convert from sigma to FWHM: FWHM = sig2fwhm * sig</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sig2fwhm</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span>

		<span class="c1"># Convert from radians to arcseconds: arcsec = rad2arcs * radians</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">rad2arcs</span> <span class="o">=</span> <span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

		<span class="c1"># Length of one sidereal year in seconds ()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sidereal_year</span> <span class="o">=</span> <span class="mf">31558175.779</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">dv</span> <span class="o">=</span> <span class="n">spectrum_velocity_scale</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">log10</span> <span class="k">else</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">dw</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">log10</span> <span class="k">else</span> <span class="n">wave</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

		<span class="c1"># No resolution matching calculated yet</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">min_sig</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sig_mask</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="kc">None</span>


	<span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Interpolate the spectral resolution at wavelength *w*.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>


	<span class="k">def</span> <span class="nf">_finalize_GaussianKernelDifference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig2_pd</span><span class="p">):</span>
		<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">		Given the calculated :math:`\sigma^2_{p,d}`, calculate and save</span>
<span class="sd">		the attributes :attr:`sig_pd` and :attr:`sig_mask`.  See</span>
<span class="sd">		:func:`GaussianKernelDifference`.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">sig2_pd</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
		<span class="n">nindx</span> <span class="o">=</span> <span class="n">where_not</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">sig2_pd</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sig2_pd</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">[</span><span class="n">nindx</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig2_pd</span><span class="p">[</span><span class="n">nindx</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sig2_pd</span><span class="p">[</span><span class="n">nindx</span><span class="p">]))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sig_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sig</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>


	<span class="k">def</span> <span class="nf">_convert_vd2pd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig2_vd</span><span class="p">):</span>
		<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">		Convert from :math:`\sigma^2_{v,d}` to :math:`\sigma^2_{p,d}`.</span>
<span class="sd">		See :func:`GaussianKernelDifference`.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">sig2_vd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dv</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log10</span> <span class="k">else</span> \
			   <span class="n">sig2_vd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dw</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">())</span>


	<span class="k">def</span> <span class="nf">_convert_pd2vd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig2_pd</span><span class="p">):</span>
		<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">		Convert from :math:`\sigma^2_{p,d}` to :math:`\sigma^2_{v,d}`.</span>
<span class="sd">		See :func:`GaussianKernelDifference`.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">sig2_pd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dv</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log10</span> <span class="k">else</span> \
			   <span class="n">sig2_pd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dw</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">())</span>


<div class="viewcode-block" id="spectral_resolution.wave"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.wave">[docs]</a>	<span class="k">def</span> <span class="nf">wave</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return the wavelength vector; held by :attr:`interpolator`.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="spectral_resolution.sres"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.sres">[docs]</a>	<span class="k">def</span> <span class="nf">sres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return the resolution vector; held by :attr:`interpolator`.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="spectral_resolution.match"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.match">[docs]</a>	<span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sres</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Currently only an alias for :func:`GaussianKernelDifference`.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">GaussianKernelDifference</span><span class="p">(</span><span class="n">new_sres</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="n">no_offset</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="n">min_sig_pix</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_resolution.GaussianKernelDifference"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.GaussianKernelDifference">[docs]</a>	<span class="k">def</span> <span class="nf">GaussianKernelDifference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sres</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
		<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">		Determine the parameters of a Gaussian kernel required to</span>
<span class="sd">		convert the resolution of this object to the resolution of a</span>
<span class="sd">		different the :class:`spectral_resolution` object, *new_sres*.</span>

<span class="sd">		The spectral resolution is defined as :math:`R =</span>
<span class="sd">		\lambda/\Delta\lambda`, where :math:`\Delta\lambda` is the FWHM</span>
<span class="sd">		of the spectral resolution element.  The standard deviation of</span>
<span class="sd">		the resolution element in angstroms is then</span>

<span class="sd">		.. math::</span>

<span class="sd">			\sigma_\lambda = \frac{\lambda}{f R}, \ \ {\rm where} \ \  f</span>
<span class="sd">			= \frac{{\rm FWHM_\lambda}}{\sigma_\lambda}.</span>

<span class="sd">		Assuming a Gaussian (in angstroms) line-spread function:</span>

<span class="sd">		.. math::</span>

<span class="sd">			\sigma^2_{\lambda,2} = \sigma^2_{\lambda,1} +</span>
<span class="sd">			\sigma^2_{\lambda,d}</span>

<span class="sd">		such that</span>

<span class="sd">		.. math::</span>

<span class="sd">			\sigma^2_{\lambda,d} = \left(\frac{\lambda}{f}\right)^2</span>
<span class="sd">			(R^{-2}_2 - R^{-2}_1)</span>

<span class="sd">		is the defining parameter of the Gaussian kernel needed to take</span>
<span class="sd">		a spectrum of resolution :math:`R_1` to one with a resolution of</span>
<span class="sd">		:math:`R_2`.</span>

<span class="sd">		For input to :func:`convolution_variable_sigma`, the</span>
<span class="sd">		*wavelength-dependent* parameter of the Gaussian kernel is</span>
<span class="sd">		converted to pixels.  This function allows for the input spectra</span>
<span class="sd">		to be linearly sampled in angstroms or log10(angstroms).  For</span>
<span class="sd">		the former (*log10=False*), </span>

<span class="sd">		.. math::</span>

<span class="sd">			\sigma^2_{p,d} = \left(\frac{\lambda}{f\</span>
<span class="sd">			\delta\lambda}\right)^2 (R^{-2}_2 - R^{-2}_1)</span>

<span class="sd">		where :math:`\delta\lambda` is the size of the pixel in</span>
<span class="sd">		angstroms.  If the units are log10(angstrom) (*log10=True*), we</span>
<span class="sd">		approximate the velocity width of each pixel to be :math:`\delta</span>
<span class="sd">		v = c \ln(10.0) (\log\lambda[1]-\log\lambda[0])`, such that</span>

<span class="sd">		.. math::</span>

<span class="sd">			\sigma^2_{p,d} &amp;= \left(\frac{c}{ \delta v \lambda}\right)^2</span>
<span class="sd">			\sigma^2_{\lambda,d} \\ &amp;= \left(\frac{c}{ f\ \delta</span>
<span class="sd">			v}\right)^2 (R^{-2}_2 - R^{-2}_1)\ ;</span>

<span class="sd">		:math:`c` is the speed of light in km/s.</span>

<span class="sd">		The nominal use of this algorithm assumes :math:`R_1 \geq R_2`.</span>
<span class="sd">		However, in practice, :func:`convolution_variable_sigma` only</span>
<span class="sd">		uses a Gaussian kernel up to some minimum value of</span>
<span class="sd">		:math:`\epsilon_\sigma`; below this, the kernel is assumed to be</span>
<span class="sd">		a Delta function.  Therefore, as long as</span>

<span class="sd">		.. math::</span>

<span class="sd">			\sigma_{p,d} \equiv \sigma^2_{p,d}/\sqrt{|\sigma^2_{p,d}|}</span>
<span class="sd">			\geq -\epsilon_\sigma\ ,</span>
<span class="sd">		</span>
<span class="sd">		the behavior of :func:`convolution_variable_sigma` should not be</span>
<span class="sd">		affected.</span>

<span class="sd">		Even so, there may be spectral regions that do not have</span>
<span class="sd">		:math:`\sigma_{p,d} \geq -\epsilon_\sigma`; for such spectral</span>
<span class="sd">		regions there are three choices:</span>

<span class="sd">			(**Option 1**) trim the spectral range to only those</span>
<span class="sd">			spectral regions where the existing resolution is better</span>
<span class="sd">			than the target resolution,</span>
<span class="sd">		</span>
<span class="sd">			(**Option 2**) match the existing resolution to the target</span>
<span class="sd">			resolution up to some constant offset that must be accounted</span>
<span class="sd">			for in subsequent analyses, or</span>

<span class="sd">			(**Option 3**) allow for a wavelength dependent difference</span>
<span class="sd">			in the spectral resolution that must be accounted for in</span>
<span class="sd">			subsequent analyses.</span>

<span class="sd">		The choice of either Option 1 or 2 is selected by setting</span>
<span class="sd">		*no_offset* to, respectively, True or False; Option 1 is the</span>
<span class="sd">		default behavior.  Currently, Option 3 is not allowed.</span>

<span class="sd">		For Option 1, pixels with :math:`\sigma_{p,d} &lt;</span>
<span class="sd">		-\epsilon_\sigma` are masked (*sigma_mask = 1*); however, the</span>
<span class="sd">		returned values of :math:`\sigma_{p,d}` are left unchanged.</span>

<span class="sd">		For Option 2, we define</span>

<span class="sd">		.. math::</span>

<span class="sd">			\sigma^2_{v,o} = -{\rm min}(\sigma^2_{v,d}) - {\rm</span>
<span class="sd">			max}(\epsilon_\sigma \delta v)^2</span>

<span class="sd">		where :math:`\delta v` is constant for the logarithmically</span>
<span class="sd">		binned spectrum and is wavelength dependent for the linearly</span>
<span class="sd">		binned spectra; in the latter case, the velocity step is</span>
<span class="sd">		determined for each pixel::</span>

<span class="sd">			_wave = self.wave()</span>
<span class="sd">			dv = c * (2.0*(_wave[1:] - _wave[0:-1]) / (_wave[1:] + _wave[0:-1]))</span>

<span class="sd">		If :math:`\sigma^2_{v,o} &gt; 0.0`, it must be that :math:`{\rm</span>
<span class="sd">		min}(\sigma^2_{v,d}) &lt; -{\rm max}(\epsilon_\sigma \delta v)^2`,</span>
<span class="sd">		such that an offset should be applied.  In that case, the</span>
<span class="sd">		returned kernel parameters are</span>

<span class="sd">		.. math::</span>

<span class="sd">			\sigma^\prime_{v,d} = \sqrt{\sigma^2_{v,d} +</span>
<span class="sd">			\sigma^2_{v,o}}\ .</span>

<span class="sd">		with the units converted to pixels using the equations above, no</span>
<span class="sd">		pixels are masked, and :math:`\sqrt{\sigma^2_{v,o}}` is returned</span>
<span class="sd">		for the offset.  Otherwise, the offset is set to 0.</span>

<span class="sd">		.. todo::</span>

<span class="sd">			Allow to check cases when the convolution kernel is</span>
<span class="sd">			indpendent of wavelength such that the convolution can be</span>
<span class="sd">			sped up by performing the convolution using an FFT.  For</span>
<span class="sd">			example, in the case where the spectrum is logarithmically</span>
<span class="sd">			binned and both :math:`R_1` and :math:`R_2` are</span>
<span class="sd">			*independent* of wavelength, the convolution kernel is</span>
<span class="sd">			independent of wavelength.</span>

<span class="sd">		Args:</span>
<span class="sd">			new_sres (:class:`spectral_resolution`): Spectral resolution</span>
<span class="sd">				to match to.</span>

<span class="sd">			no_offset (bool): (Optional) Force :math:`\sigma^2_{v,o} =</span>
<span class="sd">				0` by masking regions with :math:`\sigma_{p,d} &lt;</span>
<span class="sd">				-\epsilon_\sigma`; i.e., the value of this arguments</span>
<span class="sd">				selects Option 1 (True) or Option 2 (False).</span>

<span class="sd">			min_sig_pix (float): (Optional) Minimum value of the</span>
<span class="sd">				standard deviation allowed before assuming the kernel is</span>
<span class="sd">				a Delta function.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># Save the minimum pixel sigma to allow</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">min_sig</span> <span class="o">=</span> <span class="n">min_sig_pix</span>

		<span class="c1"># Interpolate the new spectral resolution vector at the wavelengths</span>
		<span class="c1"># of the input spectral resolution</span>
		<span class="n">_wave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">()</span>
		<span class="n">_sres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sres</span><span class="p">()</span>
		<span class="n">interp_sres</span> <span class="o">=</span> <span class="n">new_sres</span><span class="p">(</span><span class="n">_wave</span><span class="p">)</span>

		<span class="c1"># Determine the variance (in angstroms) of Gaussian needed to match</span>
		<span class="c1"># input resolution to the new values</span>
		<span class="n">sig2_wd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">_wave</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sig2fwhm</span><span class="p">)</span> \
				  <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">interp_sres</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">_sres</span><span class="p">))</span>
		<span class="c1"># Convert to km/s</span>
		<span class="n">sig2_vd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">c</span><span class="o">/</span><span class="n">_wave</span><span class="p">)</span> <span class="o">*</span> <span class="n">sig2_wd</span>

		<span class="c1"># Option 1:</span>
		<span class="k">if</span> <span class="n">no_offset</span><span class="p">:</span>
			<span class="c1"># Convert the variance to pixel coordinates</span>
			<span class="n">sig2_pd</span> <span class="o">=</span> <span class="n">sig2_vd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dv</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log10</span> <span class="k">else</span> \
					  <span class="n">sig2_wd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dw</span><span class="p">)</span>
			<span class="c1"># No offset applied</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="mf">0.0</span>

		<span class="c1"># Option 2:</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># Calculate the velocity step of each pixel</span>
			<span class="n">dv</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
			<span class="c1"># Get the needed *velocity* offset (this is the square)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">sig2_vd</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sig</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">dv</span><span class="p">))</span>
			<span class="c1"># Apply it if it&#39;s larger than 0</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">sig2_vd</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="mf">0.0</span>

			<span class="c1"># Convert the variance to pixel coordinates</span>
			<span class="n">sig2_pd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_vd2pd</span><span class="p">(</span><span class="n">sig2_vd</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_finalize_GaussianKernelDifference</span><span class="p">(</span><span class="n">sig2_pd</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_resolution.offset_GaussianKernelDifference"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.offset_GaussianKernelDifference">[docs]</a>	<span class="k">def</span> <span class="nf">offset_GaussianKernelDifference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
		<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">		If the properties required to match the resolution of one</span>
<span class="sd">		spectrum to another has already been calculated (see</span>
<span class="sd">		:func:`GaussianKernelDifference`), this allows for one to apply</span>
<span class="sd">		an additional offset.  The additional offset **must** be in km/s</span>
<span class="sd">		(not pixels).</span>

<span class="sd">		The offset is applied in quadrature; however, the offset can be</span>
<span class="sd">		negative such that one can reduce :attr:`sig_pd`.  Once</span>
<span class="sd">		converted to km/s, the offset is applied by calculating:</span>

<span class="sd">		.. math::</span>
<span class="sd">		</span>
<span class="sd">			\sigma^{\prime\ 2}_{v,d} = \sigma^{2}_{v,d} +</span>
<span class="sd">			\sigma_{off}|\sigma_{off}|\ .</span>

<span class="sd">		:attr:`sig_vo` is adjusted in the same way, and the change in</span>
<span class="sd">		:math:`\sigma^{\prime\ 2}_{v,d}` is then propagated to</span>
<span class="sd">		:attr:`sig_pd` and :attr:`sig_mask`.</span>
<span class="sd">		</span>
<span class="sd">		Args:</span>
<span class="sd">			offset (float): Value of the standard deviation in km/s to</span>
<span class="sd">				add in quadrature to a previously calculated</span>
<span class="sd">				:attr:`sig_pd`.</span>
<span class="sd">		</span>
<span class="sd">		Raises:</span>
<span class="sd">			Exception: Raised if the kernel properties have not yet been</span>
<span class="sd">				defined.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No kernel defined yet.  Run GaussianKernelDifference first.&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="mf">0.0</span><span class="p">):</span>
			<span class="k">return</span>
		<span class="n">off2</span> <span class="o">=</span> <span class="n">offset</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
		<span class="n">sig2_vo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span><span class="p">)</span> <span class="o">+</span> <span class="n">off2</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">sig2_vo</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>   <span class="k">else</span> <span class="n">sig2_vo</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sig2_vo</span><span class="p">))</span>
		<span class="n">sig2_vd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_pd2vd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sig_pd</span><span class="p">))</span> <span class="o">+</span> <span class="n">off2</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_finalize_GaussianKernelDifference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_vd2pd</span><span class="p">(</span><span class="n">sig2_vd</span><span class="p">))</span></div>


<div class="viewcode-block" id="spectral_resolution.adjusted_resolution"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.adjusted_resolution">[docs]</a>	<span class="k">def</span> <span class="nf">adjusted_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">r&quot;&quot;&quot;</span>

<span class="sd">		Return the resolution that should result from applying</span>
<span class="sd">		:func:`convolution_variable_sigma` to the spectrum associated</span>
<span class="sd">		with this spectral resolution object using :attr:`sigma_pd`.</span>
<span class="sd">		I.e., calculate:</span>

<span class="sd">		.. math::</span>

<span class="sd">			R_2 = \left[ \left(\frac{f}{c}\right)^2 \sigma^2_{v,d} +</span>
<span class="sd">			R^{-2}_1\right]^{-1/2}\ . </span>

<span class="sd">		Args:</span>
<span class="sd">			indx (tuple): (Optional) Selection tuple used to return a</span>
<span class="sd">				subset of the full resolution vector.</span>

<span class="sd">		Returns:</span>
<span class="sd">			np.ndarray: The (full or selected) vector with the</span>
<span class="sd">				adjusted resolution.</span>

<span class="sd">		.. todo::</span>
<span class="sd">			Allow to reset the resolution of this object to the adjusted</span>
<span class="sd">			resolution and reset the kernel variables to None.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">indx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig2fwhm</span><span class="o">/</span><span class="n">c</span><span class="p">)</span>            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_pd2vd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">))</span>            <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sres</span><span class="p">())</span> <span class="p">)</span>

		<span class="k">return</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig2fwhm</span><span class="o">/</span><span class="n">c</span><span class="p">)</span>     <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_pd2vd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">)))[</span><span class="n">indx</span><span class="p">]</span>        <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sres</span><span class="p">()[</span><span class="n">indx</span><span class="p">])</span> <span class="p">)</span></div></div>


<div class="viewcode-block" id="match_spectral_resolution"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.match_spectral_resolution">[docs]</a><span class="k">def</span> <span class="nf">match_spectral_resolution</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">new_sres_wave</span><span class="p">,</span> <span class="n">new_sres</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">variable_offset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">new_log10</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">	Adjust the existing spectral resolution of to a **lower** resolution</span>
<span class="sd">	as best as possible.  The primary functionality is in</span>
<span class="sd">	:class:`spectral_resolution`, which determines the Gaussian kernel</span>
<span class="sd">	parameters needed to match the resolution, and</span>
<span class="sd">	:func:`convolve_variable_sigma`, which actually performs the</span>
<span class="sd">	convolution to match the resolution.</span>

<span class="sd">	In particular, see</span>
<span class="sd">	:func:`spectral_resolution.GaussianKernelDifference` for a</span>
<span class="sd">	description of how the kernel parameters are determined and how</span>
<span class="sd">	regions where the target resolution is **higher** than the existing</span>
<span class="sd">	resolution.  In this case, one of the options is to adopt an offset</span>
<span class="sd">	of the resolution (in km/s) that could be corrected for in</span>
<span class="sd">	subsequent analysis.  In this case, setting *variable_offset* to</span>
<span class="sd">	True allows the offset to be different for all input spectra.  If</span>
<span class="sd">	one expects to combine the spectra, the default behavior should be</span>
<span class="sd">	used, forcing all the spectra to have a constant offset.</span>

<span class="sd">	Args:</span>
<span class="sd">		wave (np.ndarray): A 1D or 2D (:math:`N_{\rm spec}\times</span>
<span class="sd">			N_{\rm pix}`) array with the wavelength in angstroms for a</span>
<span class="sd">			set of spectra.  The sampling may be either in linear steps</span>
<span class="sd">			of wavelength or :math:`\log_{10}` steps, as set using</span>
<span class="sd">			*log10*.</span>
<span class="sd">		flux (np.ndarray): A 1D or 2D (:math:`N_{\rm spec}\times</span>
<span class="sd">			N_{\rm pix}`) array with the flux sampled at the provided</span>
<span class="sd">			wavelengths.</span>
<span class="sd">		sres (np.ndarray): A 1D or 2D (:math:`N_{\rm spec}\times</span>
<span class="sd">			N_{\rm pix}`) array with the spectral resolution, :math:`R`,</span>
<span class="sd">			at the provided wavelengths.</span>
<span class="sd">		new_sres_wave (np.ndarray): A 1D vector with the wavelength</span>
<span class="sd">			in angstroms at which the new resolution of the input</span>
<span class="sd">			spectra has been sampled.  The sampling may be either in</span>
<span class="sd">			linear steps of wavelength or :math:`\log_{10}` steps, as</span>
<span class="sd">			set using *new_log10*.</span>
<span class="sd">		new_sres (np.ndarray): A 1D vector with the new resolution</span>
<span class="sd">			for the input spectra.</span>
<span class="sd">		ivar (np.ndarray): (Optional) A 1D or 2D (:math:`N_{\rm</span>
<span class="sd">			spec}\times N_{\rm pix}`) array with the inverse variance of</span>
<span class="sd">			the flux sampled at the provided wavelengths.  **Currently</span>
<span class="sd">			never used and, if provided, the output inverse variances</span>
<span class="sd">			are simply a carbon copy of this array.**</span>
<span class="sd">		mask (np.ndarray): (Optional) A 1D or 2D (:math:`N_{\rm</span>
<span class="sd">			spec}\times N_{\rm pix}`) array with a *uint* mask for the</span>
<span class="sd">			flux sampled at the provided wavelengths.</span>
<span class="sd">		no_offset (bool): (Optional) Force :math:`\sigma^2_{v,o} = 0` by</span>
<span class="sd">			masking regions with :math:`\sigma_{p,d} &lt;</span>
<span class="sd">			-\epsilon_\sigma`; i.e., the value of this arguments selects</span>
<span class="sd">			Option 1 (True) or Option 2 (False).  See</span>
<span class="sd">			:func:`spectral_resolution.GaussianKernelDifference`.</span>
<span class="sd">		min_sig_pix (float): (Optional) Minimum value of the standard</span>
<span class="sd">			deviation in pixels allowed before assuming the kernel is a</span>
<span class="sd">			Delta function.</span>
<span class="sd">		variable_offset (bool): (Optional) Flag to allow the offset</span>
<span class="sd">			applied to each spectrum (when the input contains more than</span>
<span class="sd">			one spectraum) to be tailored to each spectrum.  Otherwise</span>
<span class="sd">			(*variable_offset=False*) the offset is forced to be the</span>
<span class="sd">			same for all spectra.</span>
<span class="sd">		log10 (bool): (Optional) Flag that the spectrum has been binned</span>
<span class="sd">			logarithmically (base 10) in wavelength</span>
<span class="sd">		new_log10 (bool): (Optional) Flag that the coordinates of the</span>
<span class="sd">			new spectral resolution are  spectrum as been binned</span>
<span class="sd">			logarithmically (base 10) in wavelength.</span>

<span class="sd">	Returns: </span>

<span class="sd">		np.ndarray : Four or Five arrays are returned:</span>

<span class="sd">			- A 1D or 2D (:math:`N_{\rm spec}\times N_{\rm pix}`) array</span>
<span class="sd">			  with the resolution-matched flux sampled at the input</span>
<span class="sd">			  wavelengths.</span>
<span class="sd">			- A 1D or 2D (:math:`N_{\rm spec}\times N_{\rm pix}`) array</span>
<span class="sd">			  with the spectral resolution, :math:`R`, of the</span>
<span class="sd">			  resolution-matched spectra at the provided wavelengths.</span>
<span class="sd">			- A 1D vector with any constant offset in resolution **in</span>
<span class="sd">			  km/s** between the targetted value and the result.  See</span>
<span class="sd">			  :func:`spectral_resolution.GaussianKernelDifference`.</span>
<span class="sd">			- A 1D or 2D (:math:`N_{\rm spec}\times N_{\rm pix}`) array</span>
<span class="sd">			  with a *uint* mask for the resolution-matched flux sampled</span>
<span class="sd">			  at the input wavelengths.  This is returned regardless of</span>
<span class="sd">			  whether an input mask was provided.  Any pixel that had a</span>
<span class="sd">			  resolution that was lower than the target resolution (up</span>
<span class="sd">			  to some tolerance defined by *min_sig_pix*) is returned as</span>
<span class="sd">			  masked.</span>
<span class="sd">			- (Optional) A 1D or 2D (:math:`N_{\rm spec}\times N_{\rm</span>
<span class="sd">			  pix}`) array with the inverse variance of the</span>
<span class="sd">			  resolution-matched flux sampled at the input wavelengths.</span>
<span class="sd">			  **Only output if *ivar* is provided, and in that case this</span>
<span class="sd">			  is just a carbon copy of the input array.**</span>

<span class="sd">	Raises:</span>
<span class="sd">		Exception: Raised if:</span>

<span class="sd">			- the input *wave* array is 2D and the *sres* array is not;</span>
<span class="sd">			  a 1D wavelength array is allowed for a 2D *sres* array but</span>
<span class="sd">			  not vice versa</span>

<span class="sd">			- the number of spectral pixels in *wave*, *flux*, and</span>
<span class="sd">			  *sres* is not the same</span>

<span class="sd">			- the shape of the *flux*, *mask* (if provided), and *ivar*</span>
<span class="sd">			  (if provided) are not the same</span>

<span class="sd">			- the shape of the *new_sres_wave* and *new_sres* arrays</span>
<span class="sd">			  are not the same and/or not 1D</span>

<span class="sd">	.. todo::</span>

<span class="sd">		- Add interp_ext != &#39;extrapolate&#39; option?</span>
<span class="sd">		- Better way to use warnings?</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1"># Check the dimensionality of wave and sres</span>
	<span class="n">wave_matrix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
	<span class="n">sres_matrix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
	<span class="k">if</span> <span class="n">wave_matrix</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sres_matrix</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;If input wavelength array is 2D, the spectral resolution array must&#39;</span> <span class="s1">&#39; also be 2D&#39;</span><span class="p">)</span>

	<span class="c1"># Check the shapes</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wave_matrix</span> <span class="o">==</span> <span class="n">sres_matrix</span> <span class="ow">and</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">or</span> \
	   <span class="p">(</span><span class="ow">not</span> <span class="n">wave_matrix</span> <span class="ow">and</span> <span class="n">sres_matrix</span> <span class="ow">and</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Input spectral resolution and coordinate arrays must have the same&#39;</span> <span class="s1">&#39; number of spectral channels!&#39;</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wave_matrix</span> <span class="ow">and</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">or</span> \
	   <span class="p">(</span><span class="ow">not</span> <span class="n">wave_matrix</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> \
	   <span class="p">(</span><span class="ow">not</span> <span class="n">wave_matrix</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Input flux and coordinate arrays must have the same number of&#39;</span> <span class="s1">&#39; spectral channels!&#39;</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Input flux and mask arrays must have the same shape!&#39;</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ivar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ivar</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Input flux and ivar arrays must have the same shape!&#39;</span><span class="p">)</span>
		
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_sres_wave</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_sres</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;New spectral resolution and coordinate arrays must be 1D!&#39;</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">new_sres_wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">new_sres</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;New spectral resolution and coordinate arrays must have the same shape!&#39;</span><span class="p">)</span>

	<span class="c1"># Raise a warning if the new_sres vector will have to be</span>
	<span class="c1"># extrapolated for the input wavelengths</span>
	<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">new_sres_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">new_sres_wave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
		<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Mapping to the new spectral resolution will require extrapolating the&#39;</span> \
					  <span class="s1">&#39; provided input vectors!&#39;</span><span class="p">)</span>

	<span class="c1"># Initialize some variables</span>
	<span class="n">nspec</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">sigma_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
	<span class="n">new_res</span> <span class="o">=</span> <span class="n">spectral_resolution</span><span class="p">(</span><span class="n">new_sres_wave</span><span class="p">,</span> <span class="n">new_sres</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="n">new_log10</span><span class="p">)</span>
	<span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

	<span class="c1"># Get the kernel parameters necessary to match all spectra to the</span>
	<span class="c1"># new resolution</span>
	<span class="k">if</span> <span class="n">nspec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectral_resolution</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="n">log10</span><span class="p">)]</span>
		<span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">new_res</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="n">no_offset</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="n">min_sig_pix</span><span class="p">)</span>
		<span class="n">sigma_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sig_vo</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nspec</span><span class="p">):</span>
			<span class="n">_wave</span> <span class="o">=</span> <span class="n">wave</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">if</span> <span class="n">wave_matrix</span> <span class="k">else</span> <span class="n">wave</span>
			<span class="n">_sres</span> <span class="o">=</span> <span class="n">sres</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">if</span> <span class="n">sres_matrix</span> <span class="k">else</span> <span class="n">sres</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="p">[</span><span class="n">spectral_resolution</span><span class="p">(</span><span class="n">_wave</span><span class="p">,</span> <span class="n">_sres</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="n">log10</span><span class="p">)]</span>
			<span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">new_res</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="n">no_offset</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="n">min_sig_pix</span><span class="p">)</span>
			<span class="n">sigma_offset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sig_vo</span>

	<span class="c1"># Force all the offsets to be the same, if requested</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">no_offset</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">variable_offset</span><span class="p">:</span>
		<span class="n">common_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sigma_offset</span><span class="p">)</span>
		<span class="n">offset_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">common_offset</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sigma_offset</span><span class="p">))</span>
		<span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">offset_diff</span><span class="p">):</span>
			<span class="n">r</span><span class="o">.</span><span class="n">offset_GaussianKernelDifference</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

	<span class="c1"># Perform the convolutions</span>
	<span class="n">out_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
	<span class="n">out_sres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sres</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>
	<span class="n">out_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">nspec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sig_pd</span> <span class="o">&gt;</span> <span class="n">min_sig_pix</span><span class="p">)</span>
		<span class="n">out_flux</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">convolution_variable_sigma</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
		<span class="n">out_sres</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">adjusted_resolution</span><span class="p">(</span><span class="n">indx</span><span class="o">=</span><span class="n">indx</span><span class="p">)</span>
		<span class="n">out_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sig_mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nspec</span><span class="p">):</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matching resolution: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nspec</span><span class="p">))</span>
			<span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sig_pd</span> <span class="o">&gt;</span> <span class="n">min_sig_pix</span><span class="p">)</span>
			<span class="n">out_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">convolution_variable_sigma</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
			<span class="n">out_sres</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">adjusted_resolution</span><span class="p">(</span><span class="n">indx</span><span class="o">=</span><span class="n">indx</span><span class="p">)</span>
			<span class="n">out_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sig_mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>                 <span class="o">|</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>

	<span class="c1"># TODO: Add this functionality from the IDL version?</span>
	<span class="c1">#</span>
	<span class="c1"># Finally, the code masks a number of pixels at the beginning and</span>
	<span class="c1"># end of the spectra to remove regions affected by errors in the</span>
	<span class="c1"># convolution due to the censoring of the data.  The number of</span>
	<span class="c1"># pixels is the FWHM of the largest Gaussian applied in the</span>
	<span class="c1"># convolution: ceil(sig2fwhm*max(diff_sig_w)/dw).  This is currently</span>
	<span class="c1"># hard-wired and should be tested.</span>

	<span class="k">if</span> <span class="n">ivar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">out_ivar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ivar</span><span class="p">)</span>
		<span class="c1"># Handle the inverse variances then return the answers</span>
		<span class="k">return</span> <span class="n">out_flux</span><span class="p">,</span> <span class="n">out_sres</span><span class="p">,</span> <span class="n">sigma_offset</span><span class="p">,</span> <span class="n">out_mask</span><span class="p">,</span> <span class="n">out_ivar</span>

	<span class="k">return</span> <span class="n">out_flux</span><span class="p">,</span> <span class="n">out_sres</span><span class="p">,</span> <span class="n">sigma_offset</span><span class="p">,</span> <span class="n">out_mask</span></div>
    



<div class="viewcode-block" id="log_rebin"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.log_rebin">[docs]</a><span class="k">def</span> <span class="nf">log_rebin</span><span class="p">(</span><span class="n">lamRange</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">oversample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velscale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">newRange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wave_in_ang</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unobs</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	.. note::</span>
<span class="sd">	 </span>
<span class="sd">		Copyright (C) 2001-2014, Michele Cappellari</span>
<span class="sd">		E-mail: cappellari_at_astro.ox.ac.uk</span>
<span class="sd">	 </span>
<span class="sd">		This software is provided as is without any warranty whatsoever.</span>
<span class="sd">		Permission to use, for non-commercial purposes is granted.</span>
<span class="sd">		Permission to modify for personal or internal use is granted,</span>
<span class="sd">		provided this copyright and disclaimer are included unchanged at</span>
<span class="sd">		the beginning of the file. All other rights are reserved.</span>

<span class="sd">	Logarithmically rebin a spectrum, while rigorously conserving the</span>
<span class="sd">	flux.  Basically the photons in the spectrum are simply</span>
<span class="sd">	ridistributed according to a new grid of pixels, with non-uniform</span>
<span class="sd">	size in the spectral direction.</span>

<span class="sd">	This routine makes the `standard&#39; zero-order assumption that the</span>
<span class="sd">	spectrum is *constant* within each pixels. It is possible to perform</span>
<span class="sd">	log-rebinning by assuming the spectrum is represented by a</span>
<span class="sd">	piece-wise polynomial of higer degree, while still obtaining a</span>
<span class="sd">	uniquely defined linear problem, but this reduces to a deconvolution</span>
<span class="sd">	and amplifies noise.</span>

<span class="sd">	.. warning::</span>

<span class="sd">		This assumption can be poor for sharp features in the spectrum.</span>
<span class="sd">		Beware if resampling spectra with strong, marginally sampled</span>
<span class="sd">		features!</span>

<span class="sd">	This same routine can be used to compute approximate errors of the</span>
<span class="sd">	log-rebinned spectrum. To do this type the command</span>

<span class="sd">	&gt;&gt;&gt; err2New, logLam, velscale = log_rebin(lamRange, np.square(err))</span>

<span class="sd">	and the desired errors will be given by np.sqrt(err2New).</span>

<span class="sd">	.. warning::</span>

<span class="sd">		This rebinning of the error-spectrum is very *approximate* as it</span>
<span class="sd">		does not consider the correlation introduced by the rebinning!</span>

<span class="sd">	Args:</span>

<span class="sd">		lamRange (np.ndarray): two elements vector containing the</span>
<span class="sd">			central wavelength of the first and last pixels in the</span>
<span class="sd">			spectrum, which is assumed to have constant wavelength</span>
<span class="sd">			scale! E.g. from the values in the standard FITS keywords:</span>
<span class="sd">			LAMRANGE = CRVAL1 + [0,CDELT1*(NAXIS1-1)].  It must be</span>
<span class="sd">			LAMRANGE[0] &lt; LAMRANGE[1].</span>
<span class="sd">		spec (np.ndarray): Input spectrum.</span>
<span class="sd">		oversample (int): (Optional) Oversampling can be done, not to</span>
<span class="sd">			loose spectral resolution, especally for extended wavelength</span>
<span class="sd">			ranges and to avoid aliasing.  Default is to provide the</span>
<span class="sd">			same number of output pixels as input.</span>
<span class="sd">		velscale (float): Velocity scale in km/s per pixels. If this</span>
<span class="sd">			variable is not defined, then it will contain in output the</span>
<span class="sd">			velocity scale.  If this variable is defined by the user it</span>
<span class="sd">			will be used to set the output number of pixels and</span>
<span class="sd">			wavelength scale.</span>
<span class="sd">		flux (bool): (Optional) Set this keyword to preserve total flux.</span>
<span class="sd">			In this case the log rebinning changes the pixels flux in</span>
<span class="sd">			proportion to their dLam so the following command will show</span>
<span class="sd">			large differences beween the spectral shape before and after</span>
<span class="sd">			:func:`log_rebin`::</span>
<span class="sd">	 </span>
<span class="sd">				# Plot log-rebinned spectrum</span>
<span class="sd">				pyplot.plot(exp(logLam), specNew)</span>
<span class="sd">				pyplot.plot(np.arange(lamRange[0],lamRange[1],spec.size), spec, &#39;g&#39;)</span>
<span class="sd">				pyplot.show()</span>
<span class="sd">	 </span>
<span class="sd">			By default, when this keyword is *not* set, the above two</span>
<span class="sd">			lines produce two spectra that almost perfectly overlap each</span>
<span class="sd">			other.</span>
<span class="sd">		log10 (bool): (Optional) Flag that the spectrum should be binned</span>
<span class="sd">			in units of base-10 log wavelength, instead of natural log</span>
<span class="sd">		newRange (np.ndarray): (Optional) Force the spectrum to be</span>
<span class="sd">			sampled to a new spectral range (lamRange is the *existing*</span>
<span class="sd">			spectral range).</span>
<span class="sd">		wave_in_ang (bool): (Optional) Return the wavelength coordinates</span>
<span class="sd">			in angstroms, not log(angstroms)</span>
<span class="sd">		unobs (float): (Optional) Default value for unobserved spectral</span>
<span class="sd">			regions.</span>

<span class="sd">	Returns:</span>
<span class="sd">		np.ndarray, float : Returns three variables: logarithmically</span>
<span class="sd">			rebinned spectrum, the log of the wavelength at the</span>
<span class="sd">			geometric center of each pixel, and the velocity scale of</span>
<span class="sd">			each pixel in km/s.</span>
<span class="sd">		</span>
<span class="sd">	Raises:</span>
<span class="sd">		ValueError: Raised if the input spectrum is not a</span>
<span class="sd">			one-dimensional np.ndarray.</span>
<span class="sd">		</span>
<span class="sd">	*Modification History*:</span>
<span class="sd">		| **V1.0.0**: Using interpolation. Michele Cappellari, Leiden,</span>
<span class="sd">			22 October 2001</span>
<span class="sd">		| **V2.0.0**: Analytic flux conservation. MC, Potsdam, 15 June</span>
<span class="sd">			2003</span>
<span class="sd">		| **V2.1.0**: Allow a velocity scale to be specified by the</span>
<span class="sd">			user.  MC, Leiden, 2 August 2003</span>
<span class="sd">		| **V2.2.0**: Output the optional logarithmically spaced</span>
<span class="sd">			wavelength at the geometric mean of the wavelength at the</span>
<span class="sd">			border of each pixel.  Thanks to Jesus Falcon-Barroso. MC,</span>
<span class="sd">			Leiden, 5 November 2003</span>
<span class="sd">		| **V2.2.1**: Verify that lamRange[0] &lt; lamRange[1].  MC,</span>
<span class="sd">			Vicenza, 29 December 2004</span>
<span class="sd">		| **V2.2.2**: Modified the documentation after feedback from</span>
<span class="sd">			James Price.  MC, Oxford, 21 October 2010</span>
<span class="sd">		| **V2.3.0**: By default now preserve the shape of the spectrum,</span>
<span class="sd">			not the total flux. This seems what most users expect from</span>
<span class="sd">			the procedure.  Set the keyword /FLUX to preserve flux like</span>
<span class="sd">			in previous version.  MC, Oxford, 30 November 2011</span>
<span class="sd">		| **V3.0.0**: Translated from IDL into Python. MC, Santiago, 23</span>
<span class="sd">			November 2013</span>
<span class="sd">		| **V3.1.0**: Fully vectorized log_rebin. Typical speed up by</span>
<span class="sd">			two orders of magnitude.  MC, Oxford, 4 March 2014</span>
<span class="sd">		| **05 Jun 2015**: (K. Westfall, KBW) Pulled from ppxf_util.py.</span>
<span class="sd">			Conform to mangadap documentation standard.  Transcribe</span>
<span class="sd">			edits made to IDL version that provides for the log10 and</span>
<span class="sd">			newRange arguments.  Add option to return wavelength in</span>
<span class="sd">			angstroms, not log(angstroms).  Break out determination of</span>
<span class="sd">			input and output spectrum pixel coordinates to a new</span>
<span class="sd">			function, :func:`log_rebin_pix`.  Added default value for</span>
<span class="sd">			unobserved pixels.  Default behavior unchanged.</span>

<span class="sd">	.. todo::</span>

<span class="sd">		- Allow to resample an already geometrically binned spectrum</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">lamRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lamRange</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input spectrum must be a np.ndarray&#39;</span><span class="p">)</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;input spectrum must be a vector&#39;</span><span class="p">)</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

	<span class="c1"># This is broken out into a separate procedure so that it can be</span>
	<span class="c1"># called to determine the size of the rebinned spectra without</span>
	<span class="c1"># actually doing the rebinning</span>
	<span class="n">dLam</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">logscale</span><span class="p">,</span> <span class="n">velscale</span> <span class="o">=</span> \
		<span class="n">log_rebin_pix</span><span class="p">(</span><span class="n">lamRange</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">oversample</span><span class="o">=</span><span class="n">oversample</span><span class="p">,</span> <span class="n">velscale</span><span class="o">=</span><span class="n">velscale</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="n">log10</span><span class="p">,</span>
					  <span class="n">newRange</span><span class="o">=</span><span class="n">newRange</span><span class="p">)</span>

	<span class="c1"># Get the sampling of the existing spectrum</span>
	<span class="n">lim</span> <span class="o">=</span> <span class="n">lamRange</span><span class="o">/</span><span class="n">dLam</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>           <span class="c1"># All in units of dLam</span>
	<span class="n">borders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">lim</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>     <span class="c1"># Linearly sampled pixels</span>

	<span class="c1"># Set limits to a new wavelength range</span>
	<span class="k">if</span> <span class="n">newRange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">lim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">newRange</span><span class="p">)</span><span class="o">/</span><span class="n">dLam</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>

	<span class="c1"># Set the limits to the (base-10 or natural) log of the wavelength</span>
	<span class="n">logLim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lim</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">log10</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lim</span><span class="p">)</span>
	<span class="n">logLim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">logLim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">logscale</span>      <span class="c1"># Set last wavelength, based on integer # of pixels</span>

	<span class="c1"># Geometrically spaced pixel borders for the new spectrum</span>
	<span class="n">newBorders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">logLim</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">log10</span> <span class="k">else</span> \
				 <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">logLim</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

	<span class="c1"># Get the new spectrum by performing an analytic integral</span>
	<span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">newBorders</span> <span class="o">-</span> <span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
	<span class="n">specNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">k</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">specNew</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>                <span class="c1"># fix for design flaw of reduceat()</span>
	<span class="n">specNew</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">((</span><span class="n">newBorders</span> <span class="o">-</span> <span class="n">borders</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">*</span><span class="n">spec</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

	<span class="c1"># Don&#39;t conserve the flux</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">flux</span><span class="p">:</span>
		<span class="n">specNew</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">newBorders</span><span class="p">)</span>

	<span class="c1"># Output log(wavelength): log of geometric mean</span>
	<span class="n">LamNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">newBorders</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">*</span><span class="n">newBorders</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">dLam</span>

	<span class="c1"># Set values for unobserved regions</span>
	<span class="k">if</span> <span class="n">newRange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">newRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lamRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">newRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lamRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
			<span class="n">specNew</span><span class="p">[</span> <span class="p">(</span><span class="n">LamNew</span> <span class="o">&lt;</span> <span class="n">lamRange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">LamNew</span> <span class="o">&gt;</span> <span class="n">lamRange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">]</span> <span class="o">=</span> <span class="n">unobs</span>

	<span class="c1"># Return log(wavelength), if requested</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">wave_in_ang</span><span class="p">:</span>
		<span class="n">LamNew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">LamNew</span><span class="p">)</span> <span class="k">if</span> <span class="n">log10</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">LamNew</span><span class="p">)</span>

	<span class="c1"># Return spectrum, wavelength coordinates, and pixel size in km/s</span>
	<span class="k">return</span> <span class="n">specNew</span><span class="p">,</span> <span class="n">LamNew</span><span class="p">,</span> <span class="n">velscale</span></div>



<div class="viewcode-block" id="log_rebin_pix"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.log_rebin_pix">[docs]</a><span class="k">def</span> <span class="nf">log_rebin_pix</span><span class="p">(</span><span class="n">lamRange</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">oversample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velscale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">newRange</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Determine the number of new pixels and their coordinate step when</span>
<span class="sd">	rebinning a spectrum in geometrically stepped bins.  The input</span>
<span class="sd">	spectrum must be sampled linearly in wavelength.  This is primarily</span>
<span class="sd">	a support routine for :func:`log_rebin`.</span>

<span class="sd">	Although breaking this out from the main :func:`log_rebin` function</span>
<span class="sd">	leads to a few repeat calculations in that function, the use of this</span>
<span class="sd">	function is in determine a common wavelength range for a large</span>
<span class="sd">	number of spectra before resampling the spectra themselves.  See</span>
<span class="sd">	:class:`mangadap.TplLibrary` .</span>

<span class="sd">	Args:</span>
<span class="sd">		lamRange (np.ndarray): two elements vector containing the</span>
<span class="sd">			central wavelength of the first and last pixels in the</span>
<span class="sd">			spectrum, which is assumed to have constant wavelength</span>
<span class="sd">			scale! E.g. from the values in the standard FITS keywords:</span>
<span class="sd">			LAMRANGE = CRVAL1 + [0,CDELT1*(NAXIS1-1)].  It must be</span>
<span class="sd">			LAMRANGE[0] &lt; LAMRANGE[1].</span>
<span class="sd">		n (int): Number of pixels in the original spectrum.</span>
<span class="sd">		oversample (int): (Optional) Oversampling can be done, not to</span>
<span class="sd">			loose spectral resolution, especally for extended wavelength</span>
<span class="sd">			ranges and to avoid aliasing.  Default is to provide the</span>
<span class="sd">			same number of output pixels as input.</span>
<span class="sd">		velscale (float): Velocity scale in km/s per pixels. If this</span>
<span class="sd">			variable is not defined, then it will contain in output the</span>
<span class="sd">			velocity scale.  If this variable is defined by the user it</span>
<span class="sd">			will be used to set the output number of pixels and</span>
<span class="sd">			wavelength scale.</span>
<span class="sd">		log10 (bool): (Optional) Flag that the spectrum should be binned</span>
<span class="sd">			in units of base-10 log wavelength, instead of natural log</span>
<span class="sd">		newRange (np.ndarray): (Optional) Force the spectrum to be</span>
<span class="sd">			sampled to a new spectral range (lamRange is the *existing*</span>
<span class="sd">			spectral range).</span>

<span class="sd">	Returns:</span>
<span class="sd">		float, int : Returns (1) the linear wavelength step of each</span>
<span class="sd">			pixel in the input spectrum, (2) the number of pixels for</span>
<span class="sd">			the rebinned spectrum, (3) the log-linear wavelength step</span>
<span class="sd">			for each pixel in the new spectrum, (4) the velocity step</span>
<span class="sd">			for each pixel in the new spectrum.</span>

<span class="sd">	Raises:</span>
<span class="sd">		ValueError: Raised if the input wavelength range (*lamRange* or</span>
<span class="sd">			*newRange*) does not have two elements or is not sorted.</span>
<span class="sd">		</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">lamRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lamRange</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lamRange</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;lamRange must contain two elements&#39;</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">lamRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lamRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It must be lamRange[0] &lt; lamRange[1]&#39;</span><span class="p">)</span>

	<span class="c1"># Size of output spectrum</span>
	<span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">oversample</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">oversample</span><span class="p">)</span>

	<span class="c1"># Get the sampling of the existing spectrum</span>
	<span class="n">dLam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lamRange</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span>        <span class="c1"># Assume constant dLam</span>
	<span class="n">lim</span> <span class="o">=</span> <span class="n">lamRange</span><span class="o">/</span><span class="n">dLam</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>           <span class="c1"># All in units of dLam</span>

	<span class="c1"># Get the sampling for the new spectrum, if requested to be</span>
	<span class="c1"># different</span>
	<span class="k">if</span> <span class="n">newRange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">newRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">newRange</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newRange</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;newRange must contain two elements&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">newRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">newRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It must be newRange[0] &lt; newRange[1]&#39;</span><span class="p">)</span>
		<span class="n">lim</span> <span class="o">=</span> <span class="n">newRange</span><span class="o">/</span><span class="n">dLam</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>       <span class="c1"># Set limits to a new wavelength range</span>

		<span class="c1"># Adjust the length</span>
		<span class="n">nn</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">lamRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">lamRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">newRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">newRange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">dLam</span><span class="p">)</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">-</span><span class="n">nn</span> <span class="k">if</span> <span class="n">oversample</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">m</span><span class="o">-</span><span class="n">nn</span><span class="o">*</span><span class="n">oversample</span>

	<span class="c1"># Set the limits to the (base-10 or natural) log of the wavelength</span>
	<span class="n">logLim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lim</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">log10</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lim</span><span class="p">)</span>

	<span class="c1"># Set the velocity scale, if velscale not provided; otherwise force</span>
	<span class="c1"># the sampling based in the input velscale</span>
	<span class="k">if</span> <span class="n">velscale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>                        <span class="c1"># Velocity scale is not set by user</span>
		<span class="n">velscale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">logLim</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">m</span><span class="o">*</span><span class="n">c</span>    <span class="c1"># Only for output</span>
		<span class="k">if</span> <span class="n">log10</span><span class="p">:</span>
			<span class="n">velscale</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span>          <span class="c1"># Adjust to log base-10</span>

	<span class="n">logscale</span> <span class="o">=</span> <span class="n">velscale</span><span class="o">/</span><span class="n">c</span>                       <span class="c1"># dlambda/lambda = dln(lambda)</span>
	<span class="k">if</span> <span class="n">log10</span><span class="p">:</span>
		<span class="n">logscale</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span>              <span class="c1"># Convert to dlog10(lambda)</span>
	<span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">logLim</span><span class="p">)</span><span class="o">/</span><span class="n">logscale</span><span class="p">)</span>        <span class="c1"># Number of output pixels</span>

	<span class="k">return</span> <span class="n">dLam</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">logscale</span><span class="p">,</span> <span class="n">velscale</span></div>

<div class="viewcode-block" id="downgrade"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.downgrade">[docs]</a><span class="k">def</span> <span class="nf">downgrade</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">deltal_in</span><span class="p">,</span> <span class="n">sigma_galaxy</span><span class="p">,</span> <span class="n">wave_instrument</span><span class="p">,</span> <span class="n">r_instrument</span><span class="p">):</span>

	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Adapted from the manga DAP downgrader from Kyle Westfall.</span>

<span class="sd">	Downgrades an input spectrum to a given galaxy velocity dispersion</span>
<span class="sd">	using the input SEDs resolution and the resolution of the observation.</span>

<span class="sd">	Returns flux of downgraded SED.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">sig2fwhm</span>        <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span>
	<span class="n">fwhm</span>    <span class="o">=</span> <span class="n">deltal_in</span><span class="o">/</span><span class="n">wave</span><span class="o">*</span><span class="n">c</span>
	<span class="n">sigma</span>   <span class="o">=</span> <span class="n">fwhm</span><span class="o">/</span><span class="n">sig2fwhm</span>
	<span class="n">sres</span>    <span class="o">=</span> <span class="n">wave</span><span class="o">/</span><span class="n">deltal_in</span>

	<span class="n">new_sig</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
	<span class="c1"># match wavelength between model and instrument to downgrade</span>
	<span class="k">def</span> <span class="nf">find_nearest</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="o">-</span><span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
		<span class="k">return</span> <span class="n">idx</span><span class="p">,</span><span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

	<span class="k">for</span> <span class="n">wi</span><span class="p">,</span><span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wave</span><span class="p">):</span>
		<span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">wave_instrument</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
		<span class="n">sig_instrument</span> <span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">r_instrument</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">/</span><span class="n">sig2fwhm</span>
		<span class="n">new_sig</span><span class="p">[</span><span class="n">wi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma_galaxy</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span><span class="n">sig_instrument</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>

	<span class="n">new_fwhm</span>    <span class="o">=</span> <span class="n">sig2fwhm</span> <span class="o">*</span> <span class="n">new_sig</span>
	<span class="n">new_sres</span>    <span class="o">=</span> <span class="n">c</span> <span class="o">/</span> <span class="n">new_fwhm</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough wavelength points...!&quot;</span><span class="p">)</span>

	<span class="n">a_wave</span> <span class="o">=</span> <span class="n">wave</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">wave</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">b_wave</span> <span class="o">=</span> <span class="n">wave</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">wave</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

	<span class="k">if</span> <span class="n">b_wave</span><span class="o">-</span><span class="n">a_wave</span> <span class="o">&lt;</span> <span class="mf">0.000001</span><span class="o">*</span><span class="n">a_wave</span><span class="p">:</span>
		<span class="n">log_wave</span> <span class="o">=</span> <span class="kc">False</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">log_wave</span> <span class="o">=</span> <span class="kc">True</span>

	<span class="n">new_flux</span><span class="p">,</span> <span class="n">matched_sres</span><span class="p">,</span> <span class="n">sigma_offset</span><span class="p">,</span> <span class="n">new_mask</span> <span class="o">=</span> <span class="n">match_spectral_resolution</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">new_sres</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="n">log_wave</span><span class="p">,</span> <span class="n">new_log10</span><span class="o">=</span><span class="n">log_wave</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">new_flux</span></div>
</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, johan comparat.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>