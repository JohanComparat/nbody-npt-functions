<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>firefly_library &#8212; pySU, python Skies and Universes 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pySU, python Skies and Universes 1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>pySU, python Skies and Universes 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>firefly_library</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for firefly_library</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">cPickle</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">chi2</span> 


<span class="c1">#-----------------------------------------------------------------------</span>
<div class="viewcode-block" id="airtovac"><a class="viewcode-back" href="../firefly_library.html#firefly_library.airtovac">[docs]</a><span class="k">def</span> <span class="nf">airtovac</span><span class="p">(</span><span class="n">wave_air</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">	__author__ = &#39;Kyle B. Westfall&#39;</span>

<span class="sd">    Wavelengths are corrected for the index of refraction of air under</span>
<span class="sd">    standard conditions.  Wavelength values below 2000 A will not be</span>
<span class="sd">    altered.  Uses formula from Ciddor 1996, Applied Optics 62, 958.</span>

<span class="sd">    Args:</span>
<span class="sd">        wave_air (int or float): Wavelength in Angstroms, scalar or</span>
<span class="sd">            vector. If this is the only parameter supplied, it will be</span>
<span class="sd">            updated on output to contain double precision vacuum</span>
<span class="sd">            wavelength(s). </span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.float64 : The wavelength of the line in vacuum.</span>

<span class="sd">    Example:</span>
<span class="sd">        If the air wavelength is  W = 6056.125 (a Krypton line), then</span>
<span class="sd">        :func:`airtovac` returns vacuum wavelength of W = 6057.8019.</span>
<span class="sd"> </span>
<span class="sd">    *Revision history*:</span>
<span class="sd">        | Written W. Landsman                November 1991</span>
<span class="sd">        | Use Ciddor (1996) formula for better accuracy in the infrared </span>
<span class="sd">        |   Added optional output vector, W Landsman Mar 2011</span>
<span class="sd">        | Iterate for better precision W.L./D. Schlegel  Mar 2011</span>
<span class="sd">        | Transcribed to python, K.B. Westfall Apr 2015</span>

<span class="sd">    .. note::</span>
<span class="sd">        Take care within 1 A of 2000 A.   Wavelengths below 2000 A *in</span>
<span class="sd">        air* are not altered.       </span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Copy the data</span>
    <span class="n">wave_vac</span> <span class="o">=</span> <span class="n">wave_air</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wave_air</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">wave_air</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">wave_vac</span> <span class="o">&gt;</span> <span class="mf">2000.0</span>                           <span class="c1"># Only modify above 2000 A</span>
    <span class="n">Ng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">Ng</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Handle both arrays and scalars</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wave_air</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="n">_wave_air</span> <span class="o">=</span> <span class="n">wave_air</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">_wave_vac</span> <span class="o">=</span> <span class="n">wave_vac</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_wave_air</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">wave_air</span><span class="p">)</span>
            <span class="n">_wave_vac</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">wave_vac</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">sigma2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="mf">1.0e4</span><span class="o">/</span><span class="n">_wave_vac</span><span class="p">)</span>     <span class="c1">#Convert to wavenumber squared</span>
            <span class="n">fact</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">5.792105e-2</span><span class="o">/</span><span class="p">(</span><span class="mf">238.0185</span> <span class="o">-</span> <span class="n">sigma2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.67917e-3</span><span class="o">/</span><span class="p">(</span><span class="mf">57.362</span> <span class="o">-</span> <span class="n">sigma2</span><span class="p">)</span>
            <span class="n">_wave_vac</span> <span class="o">=</span> <span class="n">_wave_air</span><span class="o">*</span><span class="n">fact</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wave_air</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>        <span class="c1"># Save the result</span>
            <span class="n">wave_vac</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">_wave_vac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wave_vac</span> <span class="o">=</span> <span class="n">_wave_vac</span>

    <span class="k">return</span> <span class="n">wave_vac</span></div>

<span class="c1">#-----------------------------------------------------------------------</span>
<div class="viewcode-block" id="bisect_array"><a class="viewcode-back" href="../firefly_library.html#firefly_library.bisect_array">[docs]</a><span class="k">def</span> <span class="nf">bisect_array</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	It takes an array as input and returns the bisected array : </span>
<span class="sd">	bisected array[i] = (array[i] + array[i+1] )/2. Its lenght is one less than the array.</span>

<span class="sd">	:param array: input array</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">bisected_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bisected_array</span><span class="p">)):</span>
		<span class="n">bisected_array</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span> <span class="o">+</span> <span class="n">array</span><span class="p">[</span><span class="n">ai</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
	<span class="k">return</span> <span class="n">bisected_array</span></div>


<span class="c1">#-----------------------------------------------------------------------</span>
<div class="viewcode-block" id="max_pdf"><a class="viewcode-back" href="../firefly_library.html#firefly_library.max_pdf">[docs]</a><span class="k">def</span> <span class="nf">max_pdf</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span><span class="nb">property</span><span class="p">,</span><span class="n">sampling</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	determines the maximum of a pdf of a property for a given sampling</span>

<span class="sd">	:param probs: probabilities</span>
<span class="sd">	:param  property: property</span>
<span class="sd">	:param  sampling: sampling of the property</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">lower_limit</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="nb">property</span><span class="p">)</span>
	<span class="n">upper_limit</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">property</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">upper_limit</span><span class="o">==</span><span class="n">lower_limit</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">property</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">probs</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>

	<span class="n">property_pdf_int</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lower_limit</span><span class="p">,</span> <span class="n">upper_limit</span> <span class="o">*</span> <span class="mf">1.001</span><span class="p">,</span> <span class="p">(</span><span class="n">upper_limit</span><span class="o">-</span><span class="n">lower_limit</span><span class="p">)</span> <span class="o">/</span><span class="n">sampling</span> <span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="n">upper_limit</span> <span class="o">-</span> <span class="n">lower_limit</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.00000001</span>	
	<span class="n">prob_pdf</span> 		<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">property_pdf_int</span><span class="p">))</span>

	<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">property_pdf_int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
		<span class="n">match_prop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span><span class="nb">property</span> <span class="o">&lt;=</span> <span class="n">property_pdf_int</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">property</span> <span class="o">&gt;</span> <span class="n">property_pdf_int</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">)</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">match_prop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">continue</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">prob_pdf</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span> <span class="n">probs</span><span class="p">[</span><span class="n">match_prop</span><span class="p">]</span> <span class="p">)</span>

	<span class="n">property_pdf</span> <span class="o">=</span> <span class="n">bisect_array</span><span class="p">(</span><span class="n">property_pdf_int</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">property_pdf</span><span class="p">,</span><span class="n">prob_pdf</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prob_pdf</span><span class="p">)</span></div>

<span class="c1">#-----------------------------------------------------------------------</span>
<div class="viewcode-block" id="convert_chis_to_probs"><a class="viewcode-back" href="../firefly_library.html#firefly_library.convert_chis_to_probs">[docs]</a><span class="k">def</span> <span class="nf">convert_chis_to_probs</span><span class="p">(</span><span class="n">chis</span><span class="p">,</span><span class="n">dof</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Converts chi squares to probabilities.</span>

<span class="sd">	:param chis: array containing the chi squares.</span>
<span class="sd">	:param dof: array of degrees of freedom.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">chis</span> <span class="o">=</span> <span class="n">chis</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">chis</span><span class="p">)</span> <span class="o">*</span> <span class="n">dof</span>
	<span class="n">prob</span> <span class="o">=</span>  <span class="mf">1.0</span> <span class="o">-</span> <span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">chis</span><span class="p">,</span><span class="n">dof</span><span class="p">)</span>
	<span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">prob</span></div>

<span class="c1">#-----------------------------------------------------------------------</span>
<div class="viewcode-block" id="light_weights_to_mass"><a class="viewcode-back" href="../firefly_library.html#firefly_library.light_weights_to_mass">[docs]</a><span class="k">def</span> <span class="nf">light_weights_to_mass</span><span class="p">(</span><span class="n">light_weights</span><span class="p">,</span><span class="n">mass_factors</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Uses the data/model mass-to-light ratio to convert</span>
<span class="sd">	SSP contribution (weights) by light into </span>
<span class="sd">	SSP contributions by mass.</span>

<span class="sd">	:param light_weights: light (luminosity) weights obtained when model fitting</span>
<span class="sd">	:param mass_factors: mass factors obtained when normalizing the spectrum</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">mass_weights</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">light_weights</span><span class="p">))</span>
	<span class="n">unnorm_mass</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">light_weights</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">light_weights</span><span class="p">)):</span>
		<span class="n">unnorm_mass</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>	<span class="o">=</span> <span class="n">light_weights</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">*</span> <span class="n">mass_factors</span>
		<span class="n">mass_weights</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">unnorm_mass</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">unnorm_mass</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
	<span class="k">return</span> <span class="n">unnorm_mass</span><span class="p">,</span><span class="n">mass_weights</span></div>

<span class="c1">#-----------------------------------------------------------------------</span>
<div class="viewcode-block" id="find_closest"><a class="viewcode-back" href="../firefly_library.html#firefly_library.find_closest">[docs]</a><span class="k">def</span> <span class="nf">find_closest</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	returns the id of the target in the array A.</span>
<span class="sd">	:param A: Array, must be sorted</span>
<span class="sd">	:param target: target value to be located in the array.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="n">left</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">right</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
	<span class="n">idx</span> <span class="o">-=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">-</span> <span class="n">target</span>
	<span class="k">return</span> <span class="n">idx</span></div>

<span class="c1">#-----------------------------------------------------------------------</span>
<div class="viewcode-block" id="averages_and_errors"><a class="viewcode-back" href="../firefly_library.html#firefly_library.averages_and_errors">[docs]</a><span class="k">def</span> <span class="nf">averages_and_errors</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span><span class="n">prop</span><span class="p">,</span><span class="n">sampling</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	determines the average and error of a property for a given sampling</span>
<span class="sd">	</span>
<span class="sd">	returns : an array with the best fit value, +/- 1, 2, 3 sigma values.</span>

<span class="sd">	:param probs: probabilities</span>
<span class="sd">	:param  property: property</span>
<span class="sd">	:param  sampling: sampling of the property</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">xdf</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">max_pdf</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span><span class="n">prop</span><span class="p">,</span><span class="n">sampling</span><span class="p">)</span>
	<span class="n">cdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
	<span class="n">cdf_probspace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
		<span class="n">cdf</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[:</span><span class="n">m</span><span class="p">])</span>

	<span class="n">cdf</span> <span class="o">=</span> <span class="n">cdf</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cdf</span><span class="p">)</span>
	<span class="n">area_probspace</span> <span class="o">=</span> <span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">xdf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xdf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="n">area_probspace</span> <span class="o">=</span> <span class="n">area_probspace</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">area_probspace</span><span class="p">)</span>
	<span class="n">indx_probspace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">area_probspace</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">desc_probspace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">area_probspace</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="n">cdf_probspace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">desc_probspace</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc_probspace</span><span class="p">)):</span>
		<span class="n">cdf_probspace</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">desc_probspace</span><span class="p">[:</span><span class="n">m</span><span class="p">])</span>

	<span class="n">av_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.6827</span><span class="p">,</span><span class="mf">0.9545</span><span class="p">,</span><span class="mf">0.9973</span><span class="p">]</span> <span class="c1"># Median, + / - 1 sig, + / - 2 sig, + / - 3 sig</span>

	<span class="c1"># Sorts results by likelihood and calculates confidence intervals on sorted space</span>
	<span class="n">index_close</span> <span class="o">=</span> <span class="n">find_closest</span><span class="p">(</span><span class="n">cdf_probspace</span><span class="p">,</span> <span class="n">av_sigs</span><span class="p">)</span>
	
	<span class="n">best_fit</span> 					<span class="o">=</span> <span class="n">xdf</span><span class="p">[</span><span class="n">indx_probspace</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
	<span class="n">upper_onesig</span><span class="p">,</span><span class="n">lower_onesig</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xdf</span><span class="p">[</span><span class="n">indx_probspace</span><span class="p">[:</span><span class="n">index_close</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]),</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xdf</span><span class="p">[</span><span class="n">indx_probspace</span><span class="p">[:</span><span class="n">index_close</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
	<span class="n">upper_twosig</span><span class="p">,</span><span class="n">lower_twosig</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xdf</span><span class="p">[</span><span class="n">indx_probspace</span><span class="p">[:</span><span class="n">index_close</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]),</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xdf</span><span class="p">[</span><span class="n">indx_probspace</span><span class="p">[:</span><span class="n">index_close</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
	<span class="n">upper_thrsig</span><span class="p">,</span><span class="n">lower_thrsig</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xdf</span><span class="p">[</span><span class="n">indx_probspace</span><span class="p">[:</span><span class="n">index_close</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]),</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xdf</span><span class="p">[</span><span class="n">indx_probspace</span><span class="p">[:</span><span class="n">index_close</span><span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>

	<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">xdf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No solutions found??? FIREFLY error (see statistics.py)&#39;</span><span class="p">)</span>
	
	<span class="k">return</span> <span class="p">[</span><span class="n">best_fit</span><span class="p">,</span><span class="n">upper_onesig</span><span class="p">,</span><span class="n">lower_onesig</span><span class="p">,</span><span class="n">upper_twosig</span><span class="p">,</span><span class="n">lower_twosig</span><span class="p">,</span><span class="n">upper_thrsig</span><span class="p">,</span><span class="n">lower_thrsig</span><span class="p">]</span></div>

<span class="c1">#-----------------------------------------------------------------------</span>
<div class="viewcode-block" id="calculate_averages_pdf"><a class="viewcode-back" href="../firefly_library.html#firefly_library.calculate_averages_pdf">[docs]</a><span class="k">def</span> <span class="nf">calculate_averages_pdf</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span><span class="n">light_weights</span><span class="p">,</span><span class="n">mass_weights</span><span class="p">,</span><span class="n">unnorm_mass</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">metal</span><span class="p">,</span><span class="n">sampling</span><span class="p">,</span><span class="n">dist_lum</span><span class="p">):</span>

	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Calculates light- and mass-averaged age and metallicities.</span>
<span class="sd">	Also outputs stellar mass and mass-to-light ratios.</span>
<span class="sd">	And errors on all of these properties.</span>

<span class="sd">	It works by taking the complete set of probs-properties and</span>
<span class="sd">	maximising over the parameter range (such that solutions with</span>
<span class="sd">	equivalent values but poorer probabilities are excluded). Then,</span>
<span class="sd">	we calculate the median and 1/2 sigma confidence intervals from </span>
<span class="sd">	the derived &#39;max-pdf&#39;.</span>

<span class="sd">	NB: Solutions with identical SSP component contributions </span>
<span class="sd">	are re-scaled such that the sum of probabilities with that</span>
<span class="sd">	component = the maximum of the probabilities with that component.</span>
<span class="sd">	i.e. prob_age_ssp1 = max(all prob_age_ssp1) / sum(all prob_age_ssp1) </span>
<span class="sd">	This is so multiple similar solutions do not count multiple times.</span>

<span class="sd">	Outputs a dictionary of:</span>
<span class="sd">	- light_[property], light_[property]_[1/2/3]_sigerror</span>
<span class="sd">	- mass_[property], mass_[property]_[1/2/3]_sigerror</span>
<span class="sd">	- stellar_mass, stellar_mass_[1/2/3]_sigerror</span>
<span class="sd">	- mass_to_light, mass_to_light_[1/2/3]_sigerror</span>
<span class="sd">	- maxpdf_[property]</span>
<span class="sd">	- maxpdf_stellar_mass</span>
<span class="sd">	where [property] = [age] or [metal]</span>

<span class="sd">	:param probs: probabilities</span>
<span class="sd">	:param light_weights: light (luminosity) weights obtained when model fitting</span>
<span class="sd">	:param mass_weights: mass weights obtained when normalizing models to data</span>
<span class="sd">	:param unnorm_mass: mass weights obtained from the mass to light ratio</span>
<span class="sd">	:param age: age</span>
<span class="sd">	:param metal: metallicity</span>
<span class="sd">	:param sampling: sampling of the property</span>
<span class="sd">	:param dist_lum: luminosity distance in cm</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="c1"># Sampling number of max_pdf (100:recommended) from options</span>
	<span class="n">log_age</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
	<span class="n">log_age</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">log_age</span><span class="p">)</span><span class="o">|</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">log_age</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
	
	<span class="n">av</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># dictionnary where values are stored :</span>
	<span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_age&#39;</span><span class="p">],</span><span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_age_1_sig_plus&#39;</span><span class="p">],</span><span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_age_1_sig_minus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_age_2_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_age_2_sig_minus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_age_3_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_age_3_sig_minus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">averages_and_errors</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">light_weights</span><span class="p">,</span><span class="n">log_age</span><span class="p">),</span><span class="n">sampling</span><span class="p">)</span>
	
	<span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_metal&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_metal_1_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_metal_1_sig_minus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_metal_2_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_metal_2_sig_minus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_metal_3_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;light_metal_3_sig_minus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">averages_and_errors</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">light_weights</span><span class="p">,</span> <span class="n">metal</span><span class="p">),</span> <span class="n">sampling</span><span class="p">)</span>
	
	<span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_age&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_age_1_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_age_1_sig_minus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_age_2_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_age_2_sig_minus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_age_3_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_age_3_sig_minus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">averages_and_errors</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mass_weights</span><span class="p">,</span> <span class="n">log_age</span><span class="p">),</span> <span class="n">sampling</span><span class="p">)</span>
	
	<span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_metal&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_metal_1_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_metal_1_sig_minus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_metal_2_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_metal_2_sig_minus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_metal_3_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;mass_metal_3_sig_minus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">averages_and_errors</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mass_weights</span><span class="p">,</span> <span class="n">metal</span><span class="p">),</span> <span class="n">sampling</span><span class="p">)</span>
	
	<span class="n">conversion_factor</span> 	<span class="o">=</span> <span class="mf">10.0</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">17</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">dist_lum</span><span class="o">**</span><span class="mf">2.0</span> <span class="c1"># unit 1e-17 cm2 </span>
	<span class="n">tot_mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">unnorm_mass</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">conversion_factor</span><span class="p">)</span>
	<span class="n">av</span><span class="p">[</span><span class="s1">&#39;stellar_mass&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;stellar_mass_1_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;stellar_mass_1_sig_minus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;stellar_mass_2_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;stellar_mass_2_sig_minus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;stellar_mass_3_sig_plus&#39;</span><span class="p">],</span> <span class="n">av</span><span class="p">[</span><span class="s1">&#39;stellar_mass_3_sig_minus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">averages_and_errors</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span><span class="n">tot_mass</span><span class="p">,</span><span class="n">sampling</span><span class="p">)</span>


	<span class="k">return</span> <span class="n">av</span></div>


<span class="c1">#-----------------------------------------------------------------------</span>
<div class="viewcode-block" id="normalise_spec"><a class="viewcode-back" href="../firefly_library.html#firefly_library.normalise_spec">[docs]</a><span class="k">def</span> <span class="nf">normalise_spec</span><span class="p">(</span><span class="n">data_flux</span><span class="p">,</span><span class="n">model_flux</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Normalises all models to the median value of the spectrum.</span>
<span class="sd">	Saves the factors for later use.</span>

<span class="sd">	Outputs : normed models and translation factors.</span>

<span class="sd">	:param data_flux: observed flux in the data</span>
<span class="sd">	:param model_flux: flux from the models</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">data_norm</span> 				<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data_flux</span><span class="p">)</span>
	<span class="n">num_mods</span> 				<span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_flux</span><span class="p">)</span>
	<span class="n">model_norm</span><span class="p">,</span><span class="n">mass_factor</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_mods</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_mods</span><span class="p">)</span>
	<span class="n">normed_model_flux</span> 		<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_mods</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">model_flux</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

	<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model_flux</span><span class="p">)):</span>
		<span class="n">model_norm</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> 			<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">model_flux</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
		<span class="n">mass_factor</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> 			<span class="o">=</span> <span class="n">data_norm</span><span class="o">/</span><span class="n">model_norm</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
		<span class="n">normed_model_flux</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> 	<span class="o">=</span> <span class="n">model_flux</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">/</span> <span class="n">model_norm</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_norm</span>

	<span class="k">return</span> <span class="n">normed_model_flux</span><span class="p">,</span><span class="n">mass_factor</span></div>

<span class="c1">#-----------------------------------------------------------------------</span>
<div class="viewcode-block" id="match_data_models"><a class="viewcode-back" href="../firefly_library.html#firefly_library.match_data_models">[docs]</a><span class="k">def</span> <span class="nf">match_data_models</span><span class="p">(</span> <span class="n">data_wave_int</span><span class="p">,</span> <span class="n">data_flux_int</span><span class="p">,</span> <span class="n">data_flags</span><span class="p">,</span> <span class="n">error_flux_int</span><span class="p">,</span> <span class="n">model_wave_int</span><span class="p">,</span> <span class="n">model_flux_int</span><span class="p">,</span> <span class="n">min_wave_in</span><span class="p">,</span> <span class="n">max_wave_in</span><span class="p">,</span> <span class="n">saveDowngradedModel</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">downgradedModelFile</span> <span class="o">=</span> <span class="s2">&quot;DGmodel.txt&quot;</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	 * 0.Take data and models as inputs </span>
<span class="sd">	 * 1. interpolate data and model to the lowest sampled array.</span>
<span class="sd">		* 1.1. Defines the wavelength range on the model and on the data</span>
<span class="sd">		* 1.2. Downgrades the array, model or data, that has most sampling </span>
<span class="sd">	 	* 1.3. integrate between them to output a matched resolution array for data and model</span>
<span class="sd">	 * 2. Returns the matched wavelength array, the corresponding data, error and model arrays : matched_wave,matched_data,matched_error,matched_model</span>

<span class="sd">	:param data_wave_int: data wavelength array in the restframe</span>
<span class="sd">	:param data_flux_int: data flux array</span>
<span class="sd">	:param data_flags: data quality flag array : 1 for good data</span>
<span class="sd">	:param error_flux_int: data flux error array</span>
<span class="sd">	:param model_wave_int: model wavelength array (in the rest frame)</span>
<span class="sd">	:param model_flux_int: model flux array</span>
<span class="sd">	:param min_wave_in: minimum wavelength to be considered</span>
<span class="sd">	:param max_wave_in: maximum wavelength to be considered</span>
<span class="sd">	:param saveDowngradedModel: if True it will save the downgraded models</span>
<span class="sd">	:param downgradedModelFile: location where downgreaded models will be saved</span>
<span class="sd">	&quot;&quot;&quot;</span>  
	<span class="c1"># 1. interpolate onto the bisection of lowest sampled array.</span>
	<span class="n">num_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_flux_int</span><span class="p">)</span>
	<span class="c1"># 1.1. Defines the wavelength range on the model and on the data</span>
	<span class="n">min_wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data_wave_int</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_flags</span><span class="o">==</span><span class="mi">1</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">model_wave_int</span><span class="p">),</span><span class="n">min_wave_in</span><span class="p">])</span>
	<span class="n">max_wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data_wave_int</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_flags</span><span class="o">==</span><span class="mi">1</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">model_wave_int</span><span class="p">),</span><span class="n">max_wave_in</span><span class="p">])</span>
	<span class="c1">#print np.min(data_wave_int[np.where(data_flags==1)]), np.min(model_wave_int), min_wave_in</span>
	<span class="c1">#print np.max(data_wave_int[np.where(data_flags==1)]), np.max(model_wave_int), max_wave_in</span>
	<span class="n">loc_model</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span> <span class="n">model_wave_int</span> <span class="o">&lt;=</span> <span class="n">max_wave</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">model_wave_int</span> <span class="o">&gt;=</span> <span class="n">min_wave</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">loc_model</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The wavelength range input is below or above model wavelength coverage!&quot;</span><span class="p">)</span>
	<span class="n">model_wave</span> 	<span class="o">=</span> <span class="n">model_wave_int</span><span class="p">[</span><span class="n">loc_model</span><span class="p">]</span>
	<span class="n">num_mod</span>  	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">loc_model</span><span class="p">)</span>
	<span class="n">model_flux</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_models</span><span class="p">,</span><span class="n">num_mod</span><span class="p">))</span>

	<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_models</span><span class="p">):</span>
		<span class="n">model_flux</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_flux_int</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">loc_model</span><span class="p">]</span>
	
	<span class="n">loc_data</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span> <span class="n">data_wave_int</span> <span class="o">&lt;=</span> <span class="n">max_wave</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data_wave_int</span> <span class="o">&gt;=</span> <span class="n">min_wave</span><span class="p">))</span> 
	<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">loc_data</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The wavelength range input is below or above data wavelength coverage!&quot;</span><span class="p">)</span>
	<span class="n">num_dat</span>  	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">loc_data</span><span class="p">)</span>
	<span class="n">data_wave</span> 	<span class="o">=</span> <span class="n">data_wave_int</span><span class="p">[</span><span class="n">loc_data</span><span class="p">]</span>
	<span class="n">data_flux</span> 	<span class="o">=</span> <span class="n">data_flux_int</span><span class="p">[</span><span class="n">loc_data</span><span class="p">]</span>
	<span class="n">error_flux</span> 	<span class="o">=</span> <span class="n">error_flux_int</span><span class="p">[</span><span class="n">loc_data</span><span class="p">]</span>
	<span class="c1"># 1.2. Downgrades the array, model or data, that has most sampling </span>
	<span class="k">if</span> <span class="n">num_mod</span> <span class="o">&gt;=</span> <span class="n">num_dat</span><span class="p">:</span>
		<span class="c1">#print &quot;More model points than data points! Downgrading models to data sampling ...&quot;</span>
		<span class="n">bisect_data</span> <span class="o">=</span> <span class="n">bisect_array</span><span class="p">(</span><span class="n">data_wave</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data_wave</span><span class="p">)</span><span class="o">*</span><span class="mf">0.0000000001</span>
		<span class="n">matched_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_models</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">bisect_data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_models</span><span class="p">):</span>
			<span class="n">model_flux_bounds</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">bisect_data</span><span class="p">,</span> <span class="n">model_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
			<span class="n">combined_wave_int</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">model_wave</span><span class="p">,</span><span class="n">bisect_data</span><span class="p">))</span>
			<span class="n">combined_flux_int</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">model_flux</span><span class="p">[</span><span class="n">m</span><span class="p">],</span><span class="n">model_flux_bounds</span><span class="p">))</span>
			<span class="n">sort_indices</span> 		<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">combined_wave_int</span><span class="p">)</span>

			<span class="n">combined_wave</span> 		<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">combined_wave_int</span><span class="p">)</span>
			<span class="n">boundary_indices</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">combined_wave</span><span class="p">,</span><span class="n">bisect_data</span><span class="p">)</span>
			<span class="n">combined_flux</span> 		<span class="o">=</span> <span class="n">combined_flux_int</span><span class="p">[</span><span class="n">sort_indices</span><span class="p">]</span>

			<span class="n">len_combo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined_flux</span><span class="p">)</span>
			<span class="c1"># 1.3. produces a matched resolution array</span>
			<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundary_indices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">len_combo</span><span class="p">:</span>
					<span class="n">matched_model</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">matched_model</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">matched_model</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">combined_flux</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="p">:</span> <span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>  <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">combined_wave</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="p">:</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">combined_wave</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">-</span>  <span class="n">combined_wave</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="p">])</span>

		<span class="n">matched_wave</span> <span class="o">=</span> <span class="n">data_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">matched_data</span> <span class="o">=</span> <span class="n">data_flux</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">matched_error</span> <span class="o">=</span> <span class="n">error_flux</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="c1"># OPTION : saves the downgraded models.</span>
		<span class="k">if</span> <span class="n">saveDowngradedModel</span><span class="p">:</span>
			<span class="c1">#print &quot;saving downgraded models to &quot;,downgradedModelFile</span>
			<span class="n">f</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">downgradedModelFile</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
			<span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">([</span><span class="n">matched_wave</span><span class="p">,</span> <span class="n">matched_data</span><span class="p">,</span> <span class="n">matched_error</span><span class="p">],</span><span class="n">f</span><span class="p">)</span>
			<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

	<span class="k">else</span><span class="p">:</span>
		<span class="c1">#print &quot;More data points than model points! Downgrading data to model sampling ...&quot;</span>
		<span class="n">bisect_model</span> <span class="o">=</span> <span class="n">bisect_array</span><span class="p">(</span><span class="n">model_wave</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">model_wave</span><span class="p">)</span><span class="o">*</span><span class="mf">0.0000000001</span>
		<span class="n">boundaries</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">data_wave</span><span class="p">,</span><span class="n">bisect_model</span><span class="p">)</span>

		<span class="n">data_flux_bounds</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">bisect_model</span><span class="p">,</span> <span class="n">data_wave</span><span class="p">,</span> <span class="n">data_flux</span><span class="p">)</span>
		<span class="n">error_flux_bounds</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">bisect_model</span><span class="p">,</span> <span class="n">data_wave</span><span class="p">,</span> <span class="n">error_flux</span><span class="p">)</span>
		<span class="n">combined_wave_int</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data_wave</span><span class="p">,</span><span class="n">bisect_model</span><span class="p">))</span>
		<span class="n">combined_flux_int</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data_flux</span><span class="p">,</span><span class="n">data_flux_bounds</span><span class="p">))</span>
		<span class="n">combined_error_int</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data_flux</span><span class="p">,</span><span class="n">error_flux_bounds</span><span class="p">))</span>
		<span class="n">sort_indices</span> 		<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">combined_wave_int</span><span class="p">)</span>
	
		<span class="n">combined_wave</span> 		<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">combined_wave_int</span><span class="p">)</span>
		<span class="n">boundary_indices</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">combined_wave</span><span class="p">,</span><span class="n">bisect_model</span><span class="p">)</span>
		<span class="n">combined_flux</span> 		<span class="o">=</span> <span class="n">combined_flux_int</span><span class="p">[</span><span class="n">sort_indices</span><span class="p">]</span>
		<span class="n">combined_error</span> 		<span class="o">=</span> <span class="n">combined_error_int</span><span class="p">[</span><span class="n">sort_indices</span><span class="p">]</span>

		<span class="c1"># 1.3. produces a matched resolution array</span>
		<span class="n">matched_data</span><span class="p">,</span><span class="n">matched_error</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundary_indices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundary_indices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

		<span class="n">len_combo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined_flux</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundary_indices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">len_combo</span><span class="p">:</span>
				<span class="n">matched_data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> 	<span class="o">=</span> <span class="n">matched_data</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
				<span class="n">matched_error</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> 	<span class="o">=</span> <span class="n">matched_error</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">matched_data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">combined_flux</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">combined_wave</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span> <span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="o">/</span>  <span class="p">(</span><span class="n">combined_wave</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">combined_wave</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span><span class="p">]])</span>
				<span class="n">matched_error</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> 	<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">combined_error</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">combined_wave</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="o">/</span> <span class="p">(</span><span class="n">combined_wave</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">combined_wave</span><span class="p">[</span><span class="n">boundary_indices</span><span class="p">[</span><span class="n">l</span><span class="p">]])</span>

		<span class="n">matched_wave</span> 		<span class="o">=</span> <span class="n">model_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">matched_model</span> 		<span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_models</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">matched_wave</span><span class="p">)))</span>
		<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_models</span><span class="p">):</span>
			<span class="n">matched_model</span><span class="p">[</span><span class="n">m</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">model_flux</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">matched_wave</span><span class="p">,</span><span class="n">matched_data</span><span class="p">,</span><span class="n">matched_error</span><span class="p">,</span><span class="n">matched_model</span></div>

</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, johan comparat.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>